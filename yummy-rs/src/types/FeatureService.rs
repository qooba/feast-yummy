// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/core/FeatureService.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.FeatureService)
pub struct FeatureService {
    // message fields
    ///  User-specified specifications of this feature service.
    // @@protoc_insertion_point(field:feast.core.FeatureService.spec)
    pub spec: ::protobuf::MessageField<FeatureServiceSpec>,
    ///  System-populated metadata for this feature service.
    // @@protoc_insertion_point(field:feast.core.FeatureService.meta)
    pub meta: ::protobuf::MessageField<FeatureServiceMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.FeatureService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureService {
    fn default() -> &'a FeatureService {
        <FeatureService as ::protobuf::Message>::default_instance()
    }
}

impl FeatureService {
    pub fn new() -> FeatureService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureServiceSpec>(
            "spec",
            |m: &FeatureService| { &m.spec },
            |m: &mut FeatureService| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureServiceMeta>(
            "meta",
            |m: &FeatureService| { &m.meta },
            |m: &mut FeatureService| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureService>(
            "FeatureService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureService {
    const NAME: &'static str = "FeatureService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureService {
        FeatureService::new()
    }

    fn clear(&mut self) {
        self.spec.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureService {
        static instance: FeatureService = FeatureService {
            spec: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.FeatureServiceSpec)
pub struct FeatureServiceSpec {
    // message fields
    ///  Name of the Feature Service. Must be unique. Not updated.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.name)
    pub name: ::std::string::String,
    ///  Name of Feast project that this Feature Service belongs to.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.project)
    pub project: ::std::string::String,
    ///  Represents a projection that's to be applied on top of the FeatureView.
    ///  Contains data such as the features to use from a FeatureView.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.features)
    pub features: ::std::vec::Vec<super::FeatureViewProjection::FeatureViewProjection>,
    ///  User defined metadata
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.tags)
    pub tags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Description of the feature service.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.description)
    pub description: ::std::string::String,
    ///  Owner of the feature service.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.owner)
    pub owner: ::std::string::String,
    ///  (optional) if provided logging will be enabled for this feature service.
    // @@protoc_insertion_point(field:feast.core.FeatureServiceSpec.logging_config)
    pub logging_config: ::protobuf::MessageField<LoggingConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.FeatureServiceSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureServiceSpec {
    fn default() -> &'a FeatureServiceSpec {
        <FeatureServiceSpec as ::protobuf::Message>::default_instance()
    }
}

impl FeatureServiceSpec {
    pub fn new() -> FeatureServiceSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FeatureServiceSpec| { &m.name },
            |m: &mut FeatureServiceSpec| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &FeatureServiceSpec| { &m.project },
            |m: &mut FeatureServiceSpec| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &FeatureServiceSpec| { &m.features },
            |m: &mut FeatureServiceSpec| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "tags",
            |m: &FeatureServiceSpec| { &m.tags },
            |m: &mut FeatureServiceSpec| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &FeatureServiceSpec| { &m.description },
            |m: &mut FeatureServiceSpec| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner",
            |m: &FeatureServiceSpec| { &m.owner },
            |m: &mut FeatureServiceSpec| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoggingConfig>(
            "logging_config",
            |m: &FeatureServiceSpec| { &m.logging_config },
            |m: &mut FeatureServiceSpec| { &mut m.logging_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureServiceSpec>(
            "FeatureServiceSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureServiceSpec {
    const NAME: &'static str = "FeatureServiceSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.project = is.read_string()?;
                },
                26 => {
                    self.features.push(is.read_message()?);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.tags.insert(key, value);
                },
                42 => {
                    self.description = is.read_string()?;
                },
                50 => {
                    self.owner = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.logging_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project);
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.owner);
        }
        if let Some(v) = self.logging_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.project.is_empty() {
            os.write_string(2, &self.project)?;
        }
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if !self.owner.is_empty() {
            os.write_string(6, &self.owner)?;
        }
        if let Some(v) = self.logging_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureServiceSpec {
        FeatureServiceSpec::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.project.clear();
        self.features.clear();
        self.tags.clear();
        self.description.clear();
        self.owner.clear();
        self.logging_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureServiceSpec {
        static instance: ::protobuf::rt::Lazy<FeatureServiceSpec> = ::protobuf::rt::Lazy::new();
        instance.get(FeatureServiceSpec::new)
    }
}

impl ::protobuf::MessageFull for FeatureServiceSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureServiceSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureServiceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureServiceSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.FeatureServiceMeta)
pub struct FeatureServiceMeta {
    // message fields
    ///  Time where this Feature Service is created
    // @@protoc_insertion_point(field:feast.core.FeatureServiceMeta.created_timestamp)
    pub created_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Time where this Feature Service is last updated
    // @@protoc_insertion_point(field:feast.core.FeatureServiceMeta.last_updated_timestamp)
    pub last_updated_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.FeatureServiceMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureServiceMeta {
    fn default() -> &'a FeatureServiceMeta {
        <FeatureServiceMeta as ::protobuf::Message>::default_instance()
    }
}

impl FeatureServiceMeta {
    pub fn new() -> FeatureServiceMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_timestamp",
            |m: &FeatureServiceMeta| { &m.created_timestamp },
            |m: &mut FeatureServiceMeta| { &mut m.created_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "last_updated_timestamp",
            |m: &FeatureServiceMeta| { &m.last_updated_timestamp },
            |m: &mut FeatureServiceMeta| { &mut m.last_updated_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureServiceMeta>(
            "FeatureServiceMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureServiceMeta {
    const NAME: &'static str = "FeatureServiceMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_timestamp)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_updated_timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.created_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_updated_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.created_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.last_updated_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureServiceMeta {
        FeatureServiceMeta::new()
    }

    fn clear(&mut self) {
        self.created_timestamp.clear();
        self.last_updated_timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureServiceMeta {
        static instance: FeatureServiceMeta = FeatureServiceMeta {
            created_timestamp: ::protobuf::MessageField::none(),
            last_updated_timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureServiceMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureServiceMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureServiceMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureServiceMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.LoggingConfig)
pub struct LoggingConfig {
    // message fields
    // @@protoc_insertion_point(field:feast.core.LoggingConfig.sample_rate)
    pub sample_rate: f32,
    // message oneof groups
    pub destination: ::std::option::Option<logging_config::Destination>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoggingConfig {
    fn default() -> &'a LoggingConfig {
        <LoggingConfig as ::protobuf::Message>::default_instance()
    }
}

impl LoggingConfig {
    pub fn new() -> LoggingConfig {
        ::std::default::Default::default()
    }

    // .feast.core.LoggingConfig.FileDestination file_destination = 3;

    pub fn file_destination(&self) -> &logging_config::FileDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::FileDestination(ref v)) => v,
            _ => <logging_config::FileDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_file_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::FileDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_destination(&mut self, v: logging_config::FileDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::FileDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_destination(&mut self) -> &mut logging_config::FileDestination {
        if let ::std::option::Option::Some(logging_config::Destination::FileDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::FileDestination(logging_config::FileDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::FileDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_destination(&mut self) -> logging_config::FileDestination {
        if self.has_file_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::FileDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::FileDestination::new()
        }
    }

    // .feast.core.LoggingConfig.BigQueryDestination bigquery_destination = 4;

    pub fn bigquery_destination(&self) -> &logging_config::BigQueryDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(ref v)) => v,
            _ => <logging_config::BigQueryDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bigquery_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_bigquery_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: logging_config::BigQueryDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_destination(&mut self) -> &mut logging_config::BigQueryDestination {
        if let ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(logging_config::BigQueryDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> logging_config::BigQueryDestination {
        if self.has_bigquery_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::BigQueryDestination::new()
        }
    }

    // .feast.core.LoggingConfig.RedshiftDestination redshift_destination = 5;

    pub fn redshift_destination(&self) -> &logging_config::RedshiftDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(ref v)) => v,
            _ => <logging_config::RedshiftDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_redshift_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_redshift_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redshift_destination(&mut self, v: logging_config::RedshiftDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redshift_destination(&mut self) -> &mut logging_config::RedshiftDestination {
        if let ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(logging_config::RedshiftDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redshift_destination(&mut self) -> logging_config::RedshiftDestination {
        if self.has_redshift_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::RedshiftDestination::new()
        }
    }

    // .feast.core.LoggingConfig.SnowflakeDestination snowflake_destination = 6;

    pub fn snowflake_destination(&self) -> &logging_config::SnowflakeDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(ref v)) => v,
            _ => <logging_config::SnowflakeDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_snowflake_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_snowflake_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snowflake_destination(&mut self, v: logging_config::SnowflakeDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snowflake_destination(&mut self) -> &mut logging_config::SnowflakeDestination {
        if let ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(logging_config::SnowflakeDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snowflake_destination(&mut self) -> logging_config::SnowflakeDestination {
        if self.has_snowflake_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::SnowflakeDestination::new()
        }
    }

    // .feast.core.LoggingConfig.CustomDestination custom_destination = 7;

    pub fn custom_destination(&self) -> &logging_config::CustomDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::CustomDestination(ref v)) => v,
            _ => <logging_config::CustomDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_custom_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_custom_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::CustomDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom_destination(&mut self, v: logging_config::CustomDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::CustomDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom_destination(&mut self) -> &mut logging_config::CustomDestination {
        if let ::std::option::Option::Some(logging_config::Destination::CustomDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::CustomDestination(logging_config::CustomDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::CustomDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom_destination(&mut self) -> logging_config::CustomDestination {
        if self.has_custom_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::CustomDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::CustomDestination::new()
        }
    }

    // .feast.core.LoggingConfig.AthenaDestination athena_destination = 8;

    pub fn athena_destination(&self) -> &logging_config::AthenaDestination {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::AthenaDestination(ref v)) => v,
            _ => <logging_config::AthenaDestination as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_athena_destination(&mut self) {
        self.destination = ::std::option::Option::None;
    }

    pub fn has_athena_destination(&self) -> bool {
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::AthenaDestination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_athena_destination(&mut self, v: logging_config::AthenaDestination) {
        self.destination = ::std::option::Option::Some(logging_config::Destination::AthenaDestination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_athena_destination(&mut self) -> &mut logging_config::AthenaDestination {
        if let ::std::option::Option::Some(logging_config::Destination::AthenaDestination(_)) = self.destination {
        } else {
            self.destination = ::std::option::Option::Some(logging_config::Destination::AthenaDestination(logging_config::AthenaDestination::new()));
        }
        match self.destination {
            ::std::option::Option::Some(logging_config::Destination::AthenaDestination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_athena_destination(&mut self) -> logging_config::AthenaDestination {
        if self.has_athena_destination() {
            match self.destination.take() {
                ::std::option::Option::Some(logging_config::Destination::AthenaDestination(v)) => v,
                _ => panic!(),
            }
        } else {
            logging_config::AthenaDestination::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &LoggingConfig| { &m.sample_rate },
            |m: &mut LoggingConfig| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::FileDestination>(
            "file_destination",
            LoggingConfig::has_file_destination,
            LoggingConfig::file_destination,
            LoggingConfig::mut_file_destination,
            LoggingConfig::set_file_destination,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::BigQueryDestination>(
            "bigquery_destination",
            LoggingConfig::has_bigquery_destination,
            LoggingConfig::bigquery_destination,
            LoggingConfig::mut_bigquery_destination,
            LoggingConfig::set_bigquery_destination,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::RedshiftDestination>(
            "redshift_destination",
            LoggingConfig::has_redshift_destination,
            LoggingConfig::redshift_destination,
            LoggingConfig::mut_redshift_destination,
            LoggingConfig::set_redshift_destination,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::SnowflakeDestination>(
            "snowflake_destination",
            LoggingConfig::has_snowflake_destination,
            LoggingConfig::snowflake_destination,
            LoggingConfig::mut_snowflake_destination,
            LoggingConfig::set_snowflake_destination,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::CustomDestination>(
            "custom_destination",
            LoggingConfig::has_custom_destination,
            LoggingConfig::custom_destination,
            LoggingConfig::mut_custom_destination,
            LoggingConfig::set_custom_destination,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, logging_config::AthenaDestination>(
            "athena_destination",
            LoggingConfig::has_athena_destination,
            LoggingConfig::athena_destination,
            LoggingConfig::mut_athena_destination,
            LoggingConfig::set_athena_destination,
        ));
        oneofs.push(logging_config::Destination::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoggingConfig>(
            "LoggingConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoggingConfig {
    const NAME: &'static str = "LoggingConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.sample_rate = is.read_float()?;
                },
                26 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::FileDestination(is.read_message()?));
                },
                34 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::BigqueryDestination(is.read_message()?));
                },
                42 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::RedshiftDestination(is.read_message()?));
                },
                50 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::SnowflakeDestination(is.read_message()?));
                },
                58 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::CustomDestination(is.read_message()?));
                },
                66 => {
                    self.destination = ::std::option::Option::Some(logging_config::Destination::AthenaDestination(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sample_rate != 0. {
            my_size += 1 + 4;
        }
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &logging_config::Destination::FileDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &logging_config::Destination::BigqueryDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &logging_config::Destination::RedshiftDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &logging_config::Destination::SnowflakeDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &logging_config::Destination::CustomDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &logging_config::Destination::AthenaDestination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sample_rate != 0. {
            os.write_float(1, self.sample_rate)?;
        }
        if let ::std::option::Option::Some(ref v) = self.destination {
            match v {
                &logging_config::Destination::FileDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &logging_config::Destination::BigqueryDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &logging_config::Destination::RedshiftDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &logging_config::Destination::SnowflakeDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &logging_config::Destination::CustomDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &logging_config::Destination::AthenaDestination(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoggingConfig {
        LoggingConfig::new()
    }

    fn clear(&mut self) {
        self.sample_rate = 0.;
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.destination = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoggingConfig {
        static instance: LoggingConfig = LoggingConfig {
            sample_rate: 0.,
            destination: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoggingConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoggingConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoggingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoggingConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoggingConfig`
pub mod logging_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.core.LoggingConfig.destination)
    pub enum Destination {
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.file_destination)
        FileDestination(FileDestination),
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.bigquery_destination)
        BigqueryDestination(BigQueryDestination),
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.redshift_destination)
        RedshiftDestination(RedshiftDestination),
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.snowflake_destination)
        SnowflakeDestination(SnowflakeDestination),
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.custom_destination)
        CustomDestination(CustomDestination),
        // @@protoc_insertion_point(oneof_field:feast.core.LoggingConfig.athena_destination)
        AthenaDestination(AthenaDestination),
    }

    impl ::protobuf::Oneof for Destination {
    }

    impl ::protobuf::OneofFull for Destination {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoggingConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("destination").unwrap()).clone()
        }
    }

    impl Destination {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Destination>("destination")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.FileDestination)
    pub struct FileDestination {
        // message fields
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.FileDestination.path)
        pub path: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.FileDestination.s3_endpoint_override)
        pub s3_endpoint_override: ::std::string::String,
        ///  column names to use for partitioning
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.FileDestination.partition_by)
        pub partition_by: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.FileDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FileDestination {
        fn default() -> &'a FileDestination {
            <FileDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl FileDestination {
        pub fn new() -> FileDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "path",
                |m: &FileDestination| { &m.path },
                |m: &mut FileDestination| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "s3_endpoint_override",
                |m: &FileDestination| { &m.s3_endpoint_override },
                |m: &mut FileDestination| { &mut m.s3_endpoint_override },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "partition_by",
                |m: &FileDestination| { &m.partition_by },
                |m: &mut FileDestination| { &mut m.partition_by },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDestination>(
                "LoggingConfig.FileDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FileDestination {
        const NAME: &'static str = "FileDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.path = is.read_string()?;
                    },
                    18 => {
                        self.s3_endpoint_override = is.read_string()?;
                    },
                    26 => {
                        self.partition_by.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.path.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.path);
            }
            if !self.s3_endpoint_override.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.s3_endpoint_override);
            }
            for value in &self.partition_by {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.path.is_empty() {
                os.write_string(1, &self.path)?;
            }
            if !self.s3_endpoint_override.is_empty() {
                os.write_string(2, &self.s3_endpoint_override)?;
            }
            for v in &self.partition_by {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FileDestination {
            FileDestination::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.s3_endpoint_override.clear();
            self.partition_by.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FileDestination {
            static instance: FileDestination = FileDestination {
                path: ::std::string::String::new(),
                s3_endpoint_override: ::std::string::String::new(),
                partition_by: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FileDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.FileDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FileDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FileDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.BigQueryDestination)
    pub struct BigQueryDestination {
        // message fields
        ///  Full table reference in the form of [project:dataset.table]
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.BigQueryDestination.table_ref)
        pub table_ref: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.BigQueryDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BigQueryDestination {
        fn default() -> &'a BigQueryDestination {
            <BigQueryDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl BigQueryDestination {
        pub fn new() -> BigQueryDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table_ref",
                |m: &BigQueryDestination| { &m.table_ref },
                |m: &mut BigQueryDestination| { &mut m.table_ref },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BigQueryDestination>(
                "LoggingConfig.BigQueryDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BigQueryDestination {
        const NAME: &'static str = "BigQueryDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table_ref = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table_ref.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table_ref);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table_ref.is_empty() {
                os.write_string(1, &self.table_ref)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BigQueryDestination {
            BigQueryDestination::new()
        }

        fn clear(&mut self) {
            self.table_ref.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BigQueryDestination {
            static instance: BigQueryDestination = BigQueryDestination {
                table_ref: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BigQueryDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.BigQueryDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BigQueryDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BigQueryDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.RedshiftDestination)
    pub struct RedshiftDestination {
        // message fields
        ///  Destination table name. ClusterId and database will be taken from an offline store config
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.RedshiftDestination.table_name)
        pub table_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.RedshiftDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RedshiftDestination {
        fn default() -> &'a RedshiftDestination {
            <RedshiftDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl RedshiftDestination {
        pub fn new() -> RedshiftDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table_name",
                |m: &RedshiftDestination| { &m.table_name },
                |m: &mut RedshiftDestination| { &mut m.table_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedshiftDestination>(
                "LoggingConfig.RedshiftDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RedshiftDestination {
        const NAME: &'static str = "RedshiftDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table_name.is_empty() {
                os.write_string(1, &self.table_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RedshiftDestination {
            RedshiftDestination::new()
        }

        fn clear(&mut self) {
            self.table_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RedshiftDestination {
            static instance: RedshiftDestination = RedshiftDestination {
                table_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RedshiftDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.RedshiftDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RedshiftDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RedshiftDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.AthenaDestination)
    pub struct AthenaDestination {
        // message fields
        ///  Destination table name. data_source and database will be taken from an offline store config
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.AthenaDestination.table_name)
        pub table_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.AthenaDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AthenaDestination {
        fn default() -> &'a AthenaDestination {
            <AthenaDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl AthenaDestination {
        pub fn new() -> AthenaDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table_name",
                |m: &AthenaDestination| { &m.table_name },
                |m: &mut AthenaDestination| { &mut m.table_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AthenaDestination>(
                "LoggingConfig.AthenaDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AthenaDestination {
        const NAME: &'static str = "AthenaDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table_name.is_empty() {
                os.write_string(1, &self.table_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AthenaDestination {
            AthenaDestination::new()
        }

        fn clear(&mut self) {
            self.table_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AthenaDestination {
            static instance: AthenaDestination = AthenaDestination {
                table_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AthenaDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.AthenaDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AthenaDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AthenaDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.SnowflakeDestination)
    pub struct SnowflakeDestination {
        // message fields
        ///  Destination table name. Schema and database will be taken from an offline store config
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.SnowflakeDestination.table_name)
        pub table_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.SnowflakeDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SnowflakeDestination {
        fn default() -> &'a SnowflakeDestination {
            <SnowflakeDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl SnowflakeDestination {
        pub fn new() -> SnowflakeDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table_name",
                |m: &SnowflakeDestination| { &m.table_name },
                |m: &mut SnowflakeDestination| { &mut m.table_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SnowflakeDestination>(
                "LoggingConfig.SnowflakeDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SnowflakeDestination {
        const NAME: &'static str = "SnowflakeDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table_name.is_empty() {
                os.write_string(1, &self.table_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SnowflakeDestination {
            SnowflakeDestination::new()
        }

        fn clear(&mut self) {
            self.table_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SnowflakeDestination {
            static instance: SnowflakeDestination = SnowflakeDestination {
                table_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SnowflakeDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.SnowflakeDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SnowflakeDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SnowflakeDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.LoggingConfig.CustomDestination)
    pub struct CustomDestination {
        // message fields
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.CustomDestination.kind)
        pub kind: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.LoggingConfig.CustomDestination.config)
        pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.LoggingConfig.CustomDestination.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomDestination {
        fn default() -> &'a CustomDestination {
            <CustomDestination as ::protobuf::Message>::default_instance()
        }
    }

    impl CustomDestination {
        pub fn new() -> CustomDestination {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "kind",
                |m: &CustomDestination| { &m.kind },
                |m: &mut CustomDestination| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "config",
                |m: &CustomDestination| { &m.config },
                |m: &mut CustomDestination| { &mut m.config },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomDestination>(
                "LoggingConfig.CustomDestination",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CustomDestination {
        const NAME: &'static str = "CustomDestination";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.kind = is.read_string()?;
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.config.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.kind.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.kind);
            }
            for (k, v) in &self.config {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.kind.is_empty() {
                os.write_string(1, &self.kind)?;
            }
            for (k, v) in &self.config {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomDestination {
            CustomDestination::new()
        }

        fn clear(&mut self) {
            self.kind.clear();
            self.config.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomDestination {
            static instance: ::protobuf::rt::Lazy<CustomDestination> = ::protobuf::rt::Lazy::new();
            instance.get(CustomDestination::new)
        }
    }

    impl ::protobuf::MessageFull for CustomDestination {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LoggingConfig.CustomDestination").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CustomDestination {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CustomDestination {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ffeast/core/FeatureService.proto\x12\nfeast.core\x1a\x1fgoogle/prot\
    obuf/timestamp.proto\x1a&feast/core/FeatureViewProjection.proto\"x\n\x0e\
    FeatureService\x122\n\x04spec\x18\x01\x20\x01(\x0b2\x1e.feast.core.Featu\
    reServiceSpecR\x04spec\x122\n\x04meta\x18\x02\x20\x01(\x0b2\x1e.feast.co\
    re.FeatureServiceMetaR\x04meta\"\xf2\x02\n\x12FeatureServiceSpec\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07project\x18\x02\x20\
    \x01(\tR\x07project\x12=\n\x08features\x18\x03\x20\x03(\x0b2!.feast.core\
    .FeatureViewProjectionR\x08features\x12<\n\x04tags\x18\x04\x20\x03(\x0b2\
    (.feast.core.FeatureServiceSpec.TagsEntryR\x04tags\x12\x20\n\x0bdescript\
    ion\x18\x05\x20\x01(\tR\x0bdescription\x12\x14\n\x05owner\x18\x06\x20\
    \x01(\tR\x05owner\x12@\n\x0elogging_config\x18\x07\x20\x01(\x0b2\x19.fea\
    st.core.LoggingConfigR\rloggingConfig\x1a7\n\tTagsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xaf\x01\n\x12FeatureServiceMeta\x12G\n\x11created_timest\
    amp\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x10createdTimes\
    tamp\x12P\n\x16last_updated_timestamp\x18\x02\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\x14lastUpdatedTimestamp\"\x89\t\n\rLoggingConfig\x12\
    \x1f\n\x0bsample_rate\x18\x01\x20\x01(\x02R\nsampleRate\x12V\n\x10file_d\
    estination\x18\x03\x20\x01(\x0b2).feast.core.LoggingConfig.FileDestinati\
    onH\0R\x0ffileDestination\x12b\n\x14bigquery_destination\x18\x04\x20\x01\
    (\x0b2-.feast.core.LoggingConfig.BigQueryDestinationH\0R\x13bigqueryDest\
    ination\x12b\n\x14redshift_destination\x18\x05\x20\x01(\x0b2-.feast.core\
    .LoggingConfig.RedshiftDestinationH\0R\x13redshiftDestination\x12e\n\x15\
    snowflake_destination\x18\x06\x20\x01(\x0b2..feast.core.LoggingConfig.Sn\
    owflakeDestinationH\0R\x14snowflakeDestination\x12\\\n\x12custom_destina\
    tion\x18\x07\x20\x01(\x0b2+.feast.core.LoggingConfig.CustomDestinationH\
    \0R\x11customDestination\x12\\\n\x12athena_destination\x18\x08\x20\x01(\
    \x0b2+.feast.core.LoggingConfig.AthenaDestinationH\0R\x11athenaDestinati\
    on\x1az\n\x0fFileDestination\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04pa\
    th\x120\n\x14s3_endpoint_override\x18\x02\x20\x01(\tR\x12s3EndpointOverr\
    ide\x12!\n\x0cpartition_by\x18\x03\x20\x03(\tR\x0bpartitionBy\x1a2\n\x13\
    BigQueryDestination\x12\x1b\n\ttable_ref\x18\x01\x20\x01(\tR\x08tableRef\
    \x1a4\n\x13RedshiftDestination\x12\x1d\n\ntable_name\x18\x01\x20\x01(\tR\
    \ttableName\x1a2\n\x11AthenaDestination\x12\x1d\n\ntable_name\x18\x01\
    \x20\x01(\tR\ttableName\x1a5\n\x14SnowflakeDestination\x12\x1d\n\ntable_\
    name\x18\x01\x20\x01(\tR\ttableName\x1a\xb3\x01\n\x11CustomDestination\
    \x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12O\n\x06config\x18\x02\
    \x20\x03(\x0b27.feast.core.LoggingConfig.CustomDestination.ConfigEntryR\
    \x06config\x1a9\n\x0bConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\r\n\
    \x0bdestinationBX\n\x10feast.proto.coreB\x13FeatureServiceProtoZ/github.\
    com/feast-dev/feast/go/protos/feast/coreJ\xcc\x17\n\x06\x12\x04\0\0a\x01\
    \n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x13\n\x08\
    \n\x01\x08\x12\x03\x03\0F\n\t\n\x02\x08\x0b\x12\x03\x03\0F\n\x08\n\x01\
    \x08\x12\x03\x04\04\n\t\n\x02\x08\x08\x12\x03\x04\04\n\x08\n\x01\x08\x12\
    \x03\x05\0)\n\t\n\x02\x08\x01\x12\x03\x05\0)\n\t\n\x02\x03\0\x12\x03\x07\
    \0)\n\t\n\x02\x03\x01\x12\x03\x08\00\n\n\n\x02\x04\0\x12\x04\n\0\x10\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\n\x08\x16\nE\n\x04\x04\0\x02\0\x12\x03\x0c\
    \x02\x1e\x1a8\x20User-specified\x20specifications\x20of\x20this\x20featu\
    re\x20service.\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0c\x02\x14\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x0c\x15\x19\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0c\x1c\x1d\nB\n\x04\x04\0\x02\x01\x12\x03\x0f\x02\x1e\x1a5\x20Syst\
    em-populated\x20metadata\x20for\x20this\x20feature\x20service.\n\n\x0c\n\
    \x05\x04\0\x02\x01\x06\x12\x03\x0f\x02\x14\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x0f\x15\x19\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0f\x1c\x1d\n\
    \n\n\x02\x04\x01\x12\x04\x12\0(\x01\n\n\n\x03\x04\x01\x01\x12\x03\x12\
    \x08\x1a\nH\n\x04\x04\x01\x02\0\x12\x03\x14\x02\x12\x1a;\x20Name\x20of\
    \x20the\x20Feature\x20Service.\x20Must\x20be\x20unique.\x20Not\x20update\
    d.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03\x14\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x14\
    \x10\x11\nJ\n\x04\x04\x01\x02\x01\x12\x03\x17\x02\x15\x1a=\x20Name\x20of\
    \x20Feast\x20project\x20that\x20this\x20Feature\x20Service\x20belongs\
    \x20to.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x17\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\x17\t\x10\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\x17\x13\x14\n\x96\x01\n\x04\x04\x01\x02\x02\x12\x03\x1b\x02\
    .\x1a\x88\x01\x20Represents\x20a\x20projection\x20that's\x20to\x20be\x20\
    applied\x20on\x20top\x20of\x20the\x20FeatureView.\n\x20Contains\x20data\
    \x20such\x20as\x20the\x20features\x20to\x20use\x20from\x20a\x20FeatureVi\
    ew.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x02\x06\x12\x03\x1b\x0b\x20\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
    \x03\x1b!)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1b,-\n$\n\x04\x04\
    \x01\x02\x03\x12\x03\x1e\x02\x1e\x1a\x17\x20User\x20defined\x20metadata\
    \n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03\x1e\x02\x14\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03\x1e\x15\x19\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03\x1e\x1c\x1d\n2\n\x04\x04\x01\x02\x04\x12\x03!\x02\x19\x1a%\x20Descr\
    iption\x20of\x20the\x20feature\x20service.\n\n\x0c\n\x05\x04\x01\x02\x04\
    \x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03!\t\x14\n\
    \x0c\n\x05\x04\x01\x02\x04\x03\x12\x03!\x17\x18\n,\n\x04\x04\x01\x02\x05\
    \x12\x03$\x02\x13\x1a\x1f\x20Owner\x20of\x20the\x20feature\x20service.\n\
    \n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03$\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x05\x01\x12\x03$\t\x0e\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03$\x11\
    \x12\nW\n\x04\x04\x01\x02\x06\x12\x03'\x02#\x1aJ\x20(optional)\x20if\x20\
    provided\x20logging\x20will\x20be\x20enabled\x20for\x20this\x20feature\
    \x20service.\n\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03'\x02\x0f\n\x0c\n\
    \x05\x04\x01\x02\x06\x01\x12\x03'\x10\x1e\n\x0c\n\x05\x04\x01\x02\x06\
    \x03\x12\x03'!\"\n\n\n\x02\x04\x02\x12\x04+\02\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03+\x08\x1a\n9\n\x04\x04\x02\x02\0\x12\x03-\x022\x1a,\x20Time\x20w\
    here\x20this\x20Feature\x20Service\x20is\x20created\n\n\x0c\n\x05\x04\
    \x02\x02\0\x06\x12\x03-\x02\x1b\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03-\
    \x1c-\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03-01\n>\n\x04\x04\x02\x02\x01\
    \x12\x030\x027\x1a1\x20Time\x20where\x20this\x20Feature\x20Service\x20is\
    \x20last\x20updated\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x030\x02\x1b\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x030\x1c2\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03056\n\n\n\x02\x04\x03\x12\x045\0a\x01\n\n\n\x03\x04\x03\x01\
    \x12\x035\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x036\x02\x18\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x036\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x036\x08\x13\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x036\x16\x17\n\x0c\n\x04\
    \x04\x03\x08\0\x12\x048\x02?\x03\n\x0c\n\x05\x04\x03\x08\0\x01\x12\x038\
    \x08\x13\n\x0b\n\x04\x04\x03\x02\x01\x12\x039\x04)\n\x0c\n\x05\x04\x03\
    \x02\x01\x06\x12\x039\x04\x13\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x039\
    \x14$\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x039'(\n\x0b\n\x04\x04\x03\x02\
    \x02\x12\x03:\x041\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03:\x04\x17\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x03:\x18,\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03:/0\n\x0b\n\x04\x04\x03\x02\x03\x12\x03;\x041\n\x0c\n\x05\
    \x04\x03\x02\x03\x06\x12\x03;\x04\x17\n\x0c\n\x05\x04\x03\x02\x03\x01\
    \x12\x03;\x18,\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03;/0\n\x0b\n\x04\
    \x04\x03\x02\x04\x12\x03<\x043\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\x03<\
    \x04\x18\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03<\x19.\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03<12\n\x0b\n\x04\x04\x03\x02\x05\x12\x03=\x04-\n\
    \x0c\n\x05\x04\x03\x02\x05\x06\x12\x03=\x04\x15\n\x0c\n\x05\x04\x03\x02\
    \x05\x01\x12\x03=\x16(\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03=+,\n\x0b\
    \n\x04\x04\x03\x02\x06\x12\x03>\x04-\n\x0c\n\x05\x04\x03\x02\x06\x06\x12\
    \x03>\x04\x15\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03>\x16(\n\x0c\n\x05\
    \x04\x03\x02\x06\x03\x12\x03>+,\n\x0c\n\x04\x04\x03\x03\0\x12\x04A\x02G\
    \x03\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03A\n\x19\n\r\n\x06\x04\x03\x03\
    \0\x02\0\x12\x03B\x04\x14\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x03B\
    \x04\n\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x03B\x0b\x0f\n\x0e\n\x07\
    \x04\x03\x03\0\x02\0\x03\x12\x03B\x12\x13\n\r\n\x06\x04\x03\x03\0\x02\
    \x01\x12\x03C\x04$\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x03C\x04\n\
    \n\x0e\n\x07\x04\x03\x03\0\x02\x01\x01\x12\x03C\x0b\x1f\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x01\x03\x12\x03C\"#\n5\n\x06\x04\x03\x03\0\x02\x02\x12\
    \x03F\x04%\x1a&\x20column\x20names\x20to\x20use\x20for\x20partitioning\n\
    \n\x0e\n\x07\x04\x03\x03\0\x02\x02\x04\x12\x03F\x04\x0c\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x02\x05\x12\x03F\r\x13\n\x0e\n\x07\x04\x03\x03\0\x02\x02\
    \x01\x12\x03F\x14\x20\n\x0e\n\x07\x04\x03\x03\0\x02\x02\x03\x12\x03F#$\n\
    \x0c\n\x04\x04\x03\x03\x01\x12\x04I\x02L\x03\n\x0c\n\x05\x04\x03\x03\x01\
    \x01\x12\x03I\n\x1d\nL\n\x06\x04\x03\x03\x01\x02\0\x12\x03K\x04\x19\x1a=\
    \x20Full\x20table\x20reference\x20in\x20the\x20form\x20of\x20[project:da\
    taset.table]\n\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x05\x12\x03K\x04\n\n\
    \x0e\n\x07\x04\x03\x03\x01\x02\0\x01\x12\x03K\x0b\x14\n\x0e\n\x07\x04\
    \x03\x03\x01\x02\0\x03\x12\x03K\x17\x18\n\x0c\n\x04\x04\x03\x03\x02\x12\
    \x04N\x02Q\x03\n\x0c\n\x05\x04\x03\x03\x02\x01\x12\x03N\n\x1d\nj\n\x06\
    \x04\x03\x03\x02\x02\0\x12\x03P\x04\x1a\x1a[\x20Destination\x20table\x20\
    name.\x20ClusterId\x20and\x20database\x20will\x20be\x20taken\x20from\x20\
    an\x20offline\x20store\x20config\n\n\x0e\n\x07\x04\x03\x03\x02\x02\0\x05\
    \x12\x03P\x04\n\n\x0e\n\x07\x04\x03\x03\x02\x02\0\x01\x12\x03P\x0b\x15\n\
    \x0e\n\x07\x04\x03\x03\x02\x02\0\x03\x12\x03P\x18\x19\n\x0c\n\x04\x04\
    \x03\x03\x03\x12\x04S\x02V\x03\n\x0c\n\x05\x04\x03\x03\x03\x01\x12\x03S\
    \n\x1b\nl\n\x06\x04\x03\x03\x03\x02\0\x12\x03U\x04\x1a\x1a]\x20Destinati\
    on\x20table\x20name.\x20data_source\x20and\x20database\x20will\x20be\x20\
    taken\x20from\x20an\x20offline\x20store\x20config\n\n\x0e\n\x07\x04\x03\
    \x03\x03\x02\0\x05\x12\x03U\x04\n\n\x0e\n\x07\x04\x03\x03\x03\x02\0\x01\
    \x12\x03U\x0b\x15\n\x0e\n\x07\x04\x03\x03\x03\x02\0\x03\x12\x03U\x18\x19\
    \n\x0c\n\x04\x04\x03\x03\x04\x12\x04X\x02[\x03\n\x0c\n\x05\x04\x03\x03\
    \x04\x01\x12\x03X\n\x1e\ng\n\x06\x04\x03\x03\x04\x02\0\x12\x03Z\x04\x1a\
    \x1aX\x20Destination\x20table\x20name.\x20Schema\x20and\x20database\x20w\
    ill\x20be\x20taken\x20from\x20an\x20offline\x20store\x20config\n\n\x0e\n\
    \x07\x04\x03\x03\x04\x02\0\x05\x12\x03Z\x04\n\n\x0e\n\x07\x04\x03\x03\
    \x04\x02\0\x01\x12\x03Z\x0b\x15\n\x0e\n\x07\x04\x03\x03\x04\x02\0\x03\
    \x12\x03Z\x18\x19\n\x0c\n\x04\x04\x03\x03\x05\x12\x04]\x02`\x03\n\x0c\n\
    \x05\x04\x03\x03\x05\x01\x12\x03]\n\x1b\n\r\n\x06\x04\x03\x03\x05\x02\0\
    \x12\x03^\x04\x14\n\x0e\n\x07\x04\x03\x03\x05\x02\0\x05\x12\x03^\x04\n\n\
    \x0e\n\x07\x04\x03\x03\x05\x02\0\x01\x12\x03^\x0b\x0f\n\x0e\n\x07\x04\
    \x03\x03\x05\x02\0\x03\x12\x03^\x12\x13\n\r\n\x06\x04\x03\x03\x05\x02\
    \x01\x12\x03_\x04#\n\x0e\n\x07\x04\x03\x03\x05\x02\x01\x06\x12\x03_\x04\
    \x17\n\x0e\n\x07\x04\x03\x03\x05\x02\x01\x01\x12\x03_\x18\x1e\n\x0e\n\
    \x07\x04\x03\x03\x05\x02\x01\x03\x12\x03_!\"b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::FeatureViewProjection::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(FeatureService::generated_message_descriptor_data());
            messages.push(FeatureServiceSpec::generated_message_descriptor_data());
            messages.push(FeatureServiceMeta::generated_message_descriptor_data());
            messages.push(LoggingConfig::generated_message_descriptor_data());
            messages.push(logging_config::FileDestination::generated_message_descriptor_data());
            messages.push(logging_config::BigQueryDestination::generated_message_descriptor_data());
            messages.push(logging_config::RedshiftDestination::generated_message_descriptor_data());
            messages.push(logging_config::AthenaDestination::generated_message_descriptor_data());
            messages.push(logging_config::SnowflakeDestination::generated_message_descriptor_data());
            messages.push(logging_config::CustomDestination::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
