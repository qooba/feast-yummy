// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/core/Store.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  Store provides a location where Feast reads and writes feature values.
///  Feature values will be written to the Store in the form of FeatureRow elements.
///  The way FeatureRow is encoded and decoded when it is written to and read from
///  the Store depends on the type of the Store.
///
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.Store)
pub struct Store {
    // message fields
    ///  Name of the store.
    // @@protoc_insertion_point(field:feast.core.Store.name)
    pub name: ::std::string::String,
    ///  Type of store.
    // @@protoc_insertion_point(field:feast.core.Store.type)
    pub type_: ::protobuf::EnumOrUnknown<store::StoreType>,
    ///  Feature sets to subscribe to.
    // @@protoc_insertion_point(field:feast.core.Store.subscriptions)
    pub subscriptions: ::std::vec::Vec<store::Subscription>,
    // message oneof groups
    pub config: ::std::option::Option<store::Config>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.Store.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Store {
    fn default() -> &'a Store {
        <Store as ::protobuf::Message>::default_instance()
    }
}

impl Store {
    pub fn new() -> Store {
        ::std::default::Default::default()
    }

    // .feast.core.Store.RedisConfig redis_config = 11;

    pub fn redis_config(&self) -> &store::RedisConfig {
        match self.config {
            ::std::option::Option::Some(store::Config::RedisConfig(ref v)) => v,
            _ => <store::RedisConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_redis_config(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_redis_config(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(store::Config::RedisConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redis_config(&mut self, v: store::RedisConfig) {
        self.config = ::std::option::Option::Some(store::Config::RedisConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redis_config(&mut self) -> &mut store::RedisConfig {
        if let ::std::option::Option::Some(store::Config::RedisConfig(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(store::Config::RedisConfig(store::RedisConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(store::Config::RedisConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redis_config(&mut self) -> store::RedisConfig {
        if self.has_redis_config() {
            match self.config.take() {
                ::std::option::Option::Some(store::Config::RedisConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            store::RedisConfig::new()
        }
    }

    // .feast.core.Store.RedisClusterConfig redis_cluster_config = 14;

    pub fn redis_cluster_config(&self) -> &store::RedisClusterConfig {
        match self.config {
            ::std::option::Option::Some(store::Config::RedisClusterConfig(ref v)) => v,
            _ => <store::RedisClusterConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_redis_cluster_config(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_redis_cluster_config(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(store::Config::RedisClusterConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redis_cluster_config(&mut self, v: store::RedisClusterConfig) {
        self.config = ::std::option::Option::Some(store::Config::RedisClusterConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redis_cluster_config(&mut self) -> &mut store::RedisClusterConfig {
        if let ::std::option::Option::Some(store::Config::RedisClusterConfig(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(store::Config::RedisClusterConfig(store::RedisClusterConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(store::Config::RedisClusterConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redis_cluster_config(&mut self) -> store::RedisClusterConfig {
        if self.has_redis_cluster_config() {
            match self.config.take() {
                ::std::option::Option::Some(store::Config::RedisClusterConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            store::RedisClusterConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Store| { &m.name },
            |m: &mut Store| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Store| { &m.type_ },
            |m: &mut Store| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriptions",
            |m: &Store| { &m.subscriptions },
            |m: &mut Store| { &mut m.subscriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, store::RedisConfig>(
            "redis_config",
            Store::has_redis_config,
            Store::redis_config,
            Store::mut_redis_config,
            Store::set_redis_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, store::RedisClusterConfig>(
            "redis_cluster_config",
            Store::has_redis_cluster_config,
            Store::redis_cluster_config,
            Store::mut_redis_cluster_config,
            Store::set_redis_cluster_config,
        ));
        oneofs.push(store::Config::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Store>(
            "Store",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Store {
    const NAME: &'static str = "Store";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.subscriptions.push(is.read_message()?);
                },
                90 => {
                    self.config = ::std::option::Option::Some(store::Config::RedisConfig(is.read_message()?));
                },
                114 => {
                    self.config = ::std::option::Option::Some(store::Config::RedisClusterConfig(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(store::StoreType::INVALID) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &store::Config::RedisConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &store::Config::RedisClusterConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(store::StoreType::INVALID) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.subscriptions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &store::Config::RedisConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &store::Config::RedisClusterConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Store {
        Store::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(store::StoreType::INVALID);
        self.subscriptions.clear();
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Store {
        static instance: Store = Store {
            name: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            subscriptions: ::std::vec::Vec::new(),
            config: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Store {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Store").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Store {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Store {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Store`
pub mod store {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.core.Store.config)
    pub enum Config {
        // @@protoc_insertion_point(oneof_field:feast.core.Store.redis_config)
        RedisConfig(RedisConfig),
        // @@protoc_insertion_point(oneof_field:feast.core.Store.redis_cluster_config)
        RedisClusterConfig(RedisClusterConfig),
    }

    impl ::protobuf::Oneof for Config {
    }

    impl ::protobuf::OneofFull for Config {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Store as ::protobuf::MessageFull>::descriptor().oneof_by_name("config").unwrap()).clone()
        }
    }

    impl Config {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Config>("config")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.Store.RedisConfig)
    pub struct RedisConfig {
        // message fields
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.host)
        pub host: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.port)
        pub port: i32,
        ///  Optional. The number of milliseconds to wait before retrying failed Redis connection.
        ///  By default, Feast uses exponential backoff policy and "initial_backoff_ms" sets the initial wait duration.
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.initial_backoff_ms)
        pub initial_backoff_ms: i32,
        ///  Optional. Maximum total number of retries for connecting to Redis. Default to zero retries.
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.max_retries)
        pub max_retries: i32,
        ///  Optional. How often flush data to redis
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.flush_frequency_seconds)
        pub flush_frequency_seconds: i32,
        ///  Optional. Connect over SSL.
        // @@protoc_insertion_point(field:feast.core.Store.RedisConfig.ssl)
        pub ssl: bool,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.Store.RedisConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RedisConfig {
        fn default() -> &'a RedisConfig {
            <RedisConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl RedisConfig {
        pub fn new() -> RedisConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "host",
                |m: &RedisConfig| { &m.host },
                |m: &mut RedisConfig| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "port",
                |m: &RedisConfig| { &m.port },
                |m: &mut RedisConfig| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "initial_backoff_ms",
                |m: &RedisConfig| { &m.initial_backoff_ms },
                |m: &mut RedisConfig| { &mut m.initial_backoff_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max_retries",
                |m: &RedisConfig| { &m.max_retries },
                |m: &mut RedisConfig| { &mut m.max_retries },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "flush_frequency_seconds",
                |m: &RedisConfig| { &m.flush_frequency_seconds },
                |m: &mut RedisConfig| { &mut m.flush_frequency_seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ssl",
                |m: &RedisConfig| { &m.ssl },
                |m: &mut RedisConfig| { &mut m.ssl },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedisConfig>(
                "Store.RedisConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RedisConfig {
        const NAME: &'static str = "RedisConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.host = is.read_string()?;
                    },
                    16 => {
                        self.port = is.read_int32()?;
                    },
                    24 => {
                        self.initial_backoff_ms = is.read_int32()?;
                    },
                    32 => {
                        self.max_retries = is.read_int32()?;
                    },
                    40 => {
                        self.flush_frequency_seconds = is.read_int32()?;
                    },
                    48 => {
                        self.ssl = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.host.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.host);
            }
            if self.port != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.port);
            }
            if self.initial_backoff_ms != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.initial_backoff_ms);
            }
            if self.max_retries != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.max_retries);
            }
            if self.flush_frequency_seconds != 0 {
                my_size += ::protobuf::rt::int32_size(5, self.flush_frequency_seconds);
            }
            if self.ssl != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.host.is_empty() {
                os.write_string(1, &self.host)?;
            }
            if self.port != 0 {
                os.write_int32(2, self.port)?;
            }
            if self.initial_backoff_ms != 0 {
                os.write_int32(3, self.initial_backoff_ms)?;
            }
            if self.max_retries != 0 {
                os.write_int32(4, self.max_retries)?;
            }
            if self.flush_frequency_seconds != 0 {
                os.write_int32(5, self.flush_frequency_seconds)?;
            }
            if self.ssl != false {
                os.write_bool(6, self.ssl)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RedisConfig {
            RedisConfig::new()
        }

        fn clear(&mut self) {
            self.host.clear();
            self.port = 0;
            self.initial_backoff_ms = 0;
            self.max_retries = 0;
            self.flush_frequency_seconds = 0;
            self.ssl = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RedisConfig {
            static instance: RedisConfig = RedisConfig {
                host: ::std::string::String::new(),
                port: 0,
                initial_backoff_ms: 0,
                max_retries: 0,
                flush_frequency_seconds: 0,
                ssl: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RedisConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Store.RedisConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RedisConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RedisConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.Store.RedisClusterConfig)
    pub struct RedisClusterConfig {
        // message fields
        ///  List of Redis Uri for all the nodes in Redis Cluster, comma separated. Eg. host1:6379, host2:6379
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.connection_string)
        pub connection_string: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.initial_backoff_ms)
        pub initial_backoff_ms: i32,
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.max_retries)
        pub max_retries: i32,
        ///  Optional. How often flush data to redis
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.flush_frequency_seconds)
        pub flush_frequency_seconds: i32,
        ///  Optional. Append a prefix to the Redis Key
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.key_prefix)
        pub key_prefix: ::std::string::String,
        ///  Optional. Enable fallback to another key prefix if the original key is not present.
        ///  Useful for migrating key prefix without re-ingestion. Disabled by default.
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.enable_fallback)
        pub enable_fallback: bool,
        ///  Optional. This would be the fallback prefix to use if enable_fallback is true.
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.fallback_prefix)
        pub fallback_prefix: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.Store.RedisClusterConfig.read_from)
        pub read_from: ::protobuf::EnumOrUnknown<redis_cluster_config::ReadFrom>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.Store.RedisClusterConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RedisClusterConfig {
        fn default() -> &'a RedisClusterConfig {
            <RedisClusterConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl RedisClusterConfig {
        pub fn new() -> RedisClusterConfig {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "connection_string",
                |m: &RedisClusterConfig| { &m.connection_string },
                |m: &mut RedisClusterConfig| { &mut m.connection_string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "initial_backoff_ms",
                |m: &RedisClusterConfig| { &m.initial_backoff_ms },
                |m: &mut RedisClusterConfig| { &mut m.initial_backoff_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max_retries",
                |m: &RedisClusterConfig| { &m.max_retries },
                |m: &mut RedisClusterConfig| { &mut m.max_retries },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "flush_frequency_seconds",
                |m: &RedisClusterConfig| { &m.flush_frequency_seconds },
                |m: &mut RedisClusterConfig| { &mut m.flush_frequency_seconds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key_prefix",
                |m: &RedisClusterConfig| { &m.key_prefix },
                |m: &mut RedisClusterConfig| { &mut m.key_prefix },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "enable_fallback",
                |m: &RedisClusterConfig| { &m.enable_fallback },
                |m: &mut RedisClusterConfig| { &mut m.enable_fallback },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fallback_prefix",
                |m: &RedisClusterConfig| { &m.fallback_prefix },
                |m: &mut RedisClusterConfig| { &mut m.fallback_prefix },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "read_from",
                |m: &RedisClusterConfig| { &m.read_from },
                |m: &mut RedisClusterConfig| { &mut m.read_from },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedisClusterConfig>(
                "Store.RedisClusterConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RedisClusterConfig {
        const NAME: &'static str = "RedisClusterConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.connection_string = is.read_string()?;
                    },
                    16 => {
                        self.initial_backoff_ms = is.read_int32()?;
                    },
                    24 => {
                        self.max_retries = is.read_int32()?;
                    },
                    32 => {
                        self.flush_frequency_seconds = is.read_int32()?;
                    },
                    42 => {
                        self.key_prefix = is.read_string()?;
                    },
                    48 => {
                        self.enable_fallback = is.read_bool()?;
                    },
                    58 => {
                        self.fallback_prefix = is.read_string()?;
                    },
                    64 => {
                        self.read_from = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.connection_string.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.connection_string);
            }
            if self.initial_backoff_ms != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.initial_backoff_ms);
            }
            if self.max_retries != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.max_retries);
            }
            if self.flush_frequency_seconds != 0 {
                my_size += ::protobuf::rt::int32_size(4, self.flush_frequency_seconds);
            }
            if !self.key_prefix.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.key_prefix);
            }
            if self.enable_fallback != false {
                my_size += 1 + 1;
            }
            if !self.fallback_prefix.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.fallback_prefix);
            }
            if self.read_from != ::protobuf::EnumOrUnknown::new(redis_cluster_config::ReadFrom::MASTER) {
                my_size += ::protobuf::rt::int32_size(8, self.read_from.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.connection_string.is_empty() {
                os.write_string(1, &self.connection_string)?;
            }
            if self.initial_backoff_ms != 0 {
                os.write_int32(2, self.initial_backoff_ms)?;
            }
            if self.max_retries != 0 {
                os.write_int32(3, self.max_retries)?;
            }
            if self.flush_frequency_seconds != 0 {
                os.write_int32(4, self.flush_frequency_seconds)?;
            }
            if !self.key_prefix.is_empty() {
                os.write_string(5, &self.key_prefix)?;
            }
            if self.enable_fallback != false {
                os.write_bool(6, self.enable_fallback)?;
            }
            if !self.fallback_prefix.is_empty() {
                os.write_string(7, &self.fallback_prefix)?;
            }
            if self.read_from != ::protobuf::EnumOrUnknown::new(redis_cluster_config::ReadFrom::MASTER) {
                os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.read_from))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RedisClusterConfig {
            RedisClusterConfig::new()
        }

        fn clear(&mut self) {
            self.connection_string.clear();
            self.initial_backoff_ms = 0;
            self.max_retries = 0;
            self.flush_frequency_seconds = 0;
            self.key_prefix.clear();
            self.enable_fallback = false;
            self.fallback_prefix.clear();
            self.read_from = ::protobuf::EnumOrUnknown::new(redis_cluster_config::ReadFrom::MASTER);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RedisClusterConfig {
            static instance: RedisClusterConfig = RedisClusterConfig {
                connection_string: ::std::string::String::new(),
                initial_backoff_ms: 0,
                max_retries: 0,
                flush_frequency_seconds: 0,
                key_prefix: ::std::string::String::new(),
                enable_fallback: false,
                fallback_prefix: ::std::string::String::new(),
                read_from: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RedisClusterConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Store.RedisClusterConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RedisClusterConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RedisClusterConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RedisClusterConfig`
    pub mod redis_cluster_config {
        ///  Optional. Priority of nodes when reading from cluster
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:feast.core.Store.RedisClusterConfig.ReadFrom)
        pub enum ReadFrom {
            // @@protoc_insertion_point(enum_value:feast.core.Store.RedisClusterConfig.ReadFrom.MASTER)
            MASTER = 0,
            // @@protoc_insertion_point(enum_value:feast.core.Store.RedisClusterConfig.ReadFrom.MASTER_PREFERRED)
            MASTER_PREFERRED = 1,
            // @@protoc_insertion_point(enum_value:feast.core.Store.RedisClusterConfig.ReadFrom.REPLICA)
            REPLICA = 2,
            // @@protoc_insertion_point(enum_value:feast.core.Store.RedisClusterConfig.ReadFrom.REPLICA_PREFERRED)
            REPLICA_PREFERRED = 3,
        }

        impl ::protobuf::Enum for ReadFrom {
            const NAME: &'static str = "ReadFrom";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ReadFrom> {
                match value {
                    0 => ::std::option::Option::Some(ReadFrom::MASTER),
                    1 => ::std::option::Option::Some(ReadFrom::MASTER_PREFERRED),
                    2 => ::std::option::Option::Some(ReadFrom::REPLICA),
                    3 => ::std::option::Option::Some(ReadFrom::REPLICA_PREFERRED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ReadFrom] = &[
                ReadFrom::MASTER,
                ReadFrom::MASTER_PREFERRED,
                ReadFrom::REPLICA,
                ReadFrom::REPLICA_PREFERRED,
            ];
        }

        impl ::protobuf::EnumFull for ReadFrom {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Store.RedisClusterConfig.ReadFrom").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ReadFrom {
            fn default() -> Self {
                ReadFrom::MASTER
            }
        }

        impl ReadFrom {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReadFrom>("Store.RedisClusterConfig.ReadFrom")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.Store.Subscription)
    pub struct Subscription {
        // message fields
        ///  Name of project that the feature sets belongs to. This can be one of
        ///  - [project_name]
        ///  - *
        ///  If an asterisk is provided, filtering on projects will be disabled. All projects will
        ///  be matched. It is NOT possible to provide an asterisk with a string in order to do
        ///  pattern matching.
        // @@protoc_insertion_point(field:feast.core.Store.Subscription.project)
        pub project: ::std::string::String,
        ///  Name of the desired feature set. Asterisks can be used as wildcards in the name.
        ///  Matching on names is only permitted if a specific project is defined. It is disallowed
        ///  If the project name is set to "*"
        ///  e.g.
        ///  - * can be used to match all feature sets
        ///  - my-feature-set* can be used to match all features prefixed by "my-feature-set"
        ///  - my-feature-set-6 can be used to select a single feature set
        // @@protoc_insertion_point(field:feast.core.Store.Subscription.name)
        pub name: ::std::string::String,
        ///  All matches with exclude enabled will be filtered out instead of added
        // @@protoc_insertion_point(field:feast.core.Store.Subscription.exclude)
        pub exclude: bool,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.Store.Subscription.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subscription {
        fn default() -> &'a Subscription {
            <Subscription as ::protobuf::Message>::default_instance()
        }
    }

    impl Subscription {
        pub fn new() -> Subscription {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "project",
                |m: &Subscription| { &m.project },
                |m: &mut Subscription| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Subscription| { &m.name },
                |m: &mut Subscription| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "exclude",
                |m: &Subscription| { &m.exclude },
                |m: &mut Subscription| { &mut m.exclude },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscription>(
                "Store.Subscription",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subscription {
        const NAME: &'static str = "Subscription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        self.project = is.read_string()?;
                    },
                    10 => {
                        self.name = is.read_string()?;
                    },
                    32 => {
                        self.exclude = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.project.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.project);
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if self.exclude != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.project.is_empty() {
                os.write_string(3, &self.project)?;
            }
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if self.exclude != false {
                os.write_bool(4, self.exclude)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subscription {
            Subscription::new()
        }

        fn clear(&mut self) {
            self.project.clear();
            self.name.clear();
            self.exclude = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subscription {
            static instance: Subscription = Subscription {
                project: ::std::string::String::new(),
                name: ::std::string::String::new(),
                exclude: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subscription {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Store.Subscription").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subscription {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subscription {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:feast.core.Store.StoreType)
    pub enum StoreType {
        // @@protoc_insertion_point(enum_value:feast.core.Store.StoreType.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:feast.core.Store.StoreType.REDIS)
        REDIS = 1,
        // @@protoc_insertion_point(enum_value:feast.core.Store.StoreType.REDIS_CLUSTER)
        REDIS_CLUSTER = 4,
    }

    impl ::protobuf::Enum for StoreType {
        const NAME: &'static str = "StoreType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<StoreType> {
            match value {
                0 => ::std::option::Option::Some(StoreType::INVALID),
                1 => ::std::option::Option::Some(StoreType::REDIS),
                4 => ::std::option::Option::Some(StoreType::REDIS_CLUSTER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [StoreType] = &[
            StoreType::INVALID,
            StoreType::REDIS,
            StoreType::REDIS_CLUSTER,
        ];
    }

    impl ::protobuf::EnumFull for StoreType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Store.StoreType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                StoreType::INVALID => 0,
                StoreType::REDIS => 1,
                StoreType::REDIS_CLUSTER => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for StoreType {
        fn default() -> Self {
            StoreType::INVALID
        }
    }

    impl StoreType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StoreType>("Store.StoreType")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16feast/core/Store.proto\x12\nfeast.core\"\x93\t\n\x05Store\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12/\n\x04type\x18\x02\x20\x01(\
    \x0e2\x1b.feast.core.Store.StoreTypeR\x04type\x12D\n\rsubscriptions\x18\
    \x04\x20\x03(\x0b2\x1e.feast.core.Store.SubscriptionR\rsubscriptions\x12\
    B\n\x0credis_config\x18\x0b\x20\x01(\x0b2\x1d.feast.core.Store.RedisConf\
    igH\0R\x0bredisConfig\x12X\n\x14redis_cluster_config\x18\x0e\x20\x01(\
    \x0b2$.feast.core.Store.RedisClusterConfigH\0R\x12redisClusterConfig\x1a\
    \xce\x01\n\x0bRedisConfig\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\
    \x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\x12,\n\x12initial_backo\
    ff_ms\x18\x03\x20\x01(\x05R\x10initialBackoffMs\x12\x1f\n\x0bmax_retries\
    \x18\x04\x20\x01(\x05R\nmaxRetries\x126\n\x17flush_frequency_seconds\x18\
    \x05\x20\x01(\x05R\x15flushFrequencySeconds\x12\x10\n\x03ssl\x18\x06\x20\
    \x01(\x08R\x03ssl\x1a\xd7\x03\n\x12RedisClusterConfig\x12+\n\x11connecti\
    on_string\x18\x01\x20\x01(\tR\x10connectionString\x12,\n\x12initial_back\
    off_ms\x18\x02\x20\x01(\x05R\x10initialBackoffMs\x12\x1f\n\x0bmax_retrie\
    s\x18\x03\x20\x01(\x05R\nmaxRetries\x126\n\x17flush_frequency_seconds\
    \x18\x04\x20\x01(\x05R\x15flushFrequencySeconds\x12\x1d\n\nkey_prefix\
    \x18\x05\x20\x01(\tR\tkeyPrefix\x12'\n\x0fenable_fallback\x18\x06\x20\
    \x01(\x08R\x0eenableFallback\x12'\n\x0ffallback_prefix\x18\x07\x20\x01(\
    \tR\x0efallbackPrefix\x12J\n\tread_from\x18\x08\x20\x01(\x0e2-.feast.cor\
    e.Store.RedisClusterConfig.ReadFromR\x08readFrom\"P\n\x08ReadFrom\x12\n\
    \n\x06MASTER\x10\0\x12\x14\n\x10MASTER_PREFERRED\x10\x01\x12\x0b\n\x07RE\
    PLICA\x10\x02\x12\x15\n\x11REPLICA_PREFERRED\x10\x03\x1a\\\n\x0cSubscrip\
    tion\x12\x18\n\x07project\x18\x03\x20\x01(\tR\x07project\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07exclude\x18\x04\x20\x01(\x08\
    R\x07excludeJ\x04\x08\x02\x10\x03\"N\n\tStoreType\x12\x0b\n\x07INVALID\
    \x10\0\x12\t\n\x05REDIS\x10\x01\x12\x11\n\rREDIS_CLUSTER\x10\x04\"\x04\
    \x08\x02\x10\x02\"\x04\x08\x03\x10\x03\"\x04\x08\x0c\x10\x0c\"\x04\x08\r\
    \x10\rB\x08\n\x06configBO\n\x10feast.proto.coreB\nStoreProtoZ/github.com\
    /feast-dev/feast/go/protos/feast/coreJ\x85)\n\x07\x12\x05\x10\0\x81\x01\
    \x01\n\xe0\x04\n\x01\x0c\x12\x03\x10\0\x122\xd5\x04\n\x20*\x20Copyright\
    \x202019\x20The\x20Feast\x20Authors\n\x20*\n\x20*\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20*\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20c\
    ompliance\x20with\x20the\x20License.\n\x20*\x20You\x20may\x20obtain\x20a\
    \x20copy\x20of\x20the\x20License\x20at\n\x20*\n\x20*\x20\x20\x20\x20\x20\
    https://www.apache.org/licenses/LICENSE-2.0\n\x20*\n\x20*\x20Unless\x20r\
    equired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writin\
    g,\x20software\n\x20*\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20*\x20WITHOUT\
    \x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20ex\
    press\x20or\x20implied.\n\x20*\x20See\x20the\x20License\x20for\x20the\
    \x20specific\x20language\x20governing\x20permissions\x20and\n\x20*\x20li\
    mitations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\
    \x13\n\x08\n\x01\x08\x12\x03\x13\0)\n\t\n\x02\x08\x01\x12\x03\x13\0)\n\
    \x08\n\x01\x08\x12\x03\x14\0+\n\t\n\x02\x08\x08\x12\x03\x14\0+\n\x08\n\
    \x01\x08\x12\x03\x15\0F\n\t\n\x02\x08\x0b\x12\x03\x15\0F\n\xa4\x02\n\x02\
    \x04\0\x12\x05\x1c\0\x81\x01\x01\x1a\x96\x02\x20Store\x20provides\x20a\
    \x20location\x20where\x20Feast\x20reads\x20and\x20writes\x20feature\x20v\
    alues.\n\x20Feature\x20values\x20will\x20be\x20written\x20to\x20the\x20S\
    tore\x20in\x20the\x20form\x20of\x20FeatureRow\x20elements.\n\x20The\x20w\
    ay\x20FeatureRow\x20is\x20encoded\x20and\x20decoded\x20when\x20it\x20is\
    \x20written\x20to\x20and\x20read\x20from\n\x20the\x20Store\x20depends\
    \x20on\x20the\x20type\x20of\x20the\x20Store.\n\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x1c\x08\r\n\x0c\n\x04\x04\0\x04\0\x12\x04\x1e\x021\x03\n\x0c\n\x05\
    \x04\0\x04\0\x01\x12\x03\x1e\x07\x10\n5\n\x05\x04\0\x04\0\t\x12\x03\x20\
    \x04\x1a\x1a'\x20These\x20positions\x20should\x20not\x20be\x20reused.\n\
    \n\r\n\x06\x04\0\x04\0\t\0\x12\x03\x20\r\x0e\n\x0e\n\x07\x04\0\x04\0\t\0\
    \x01\x12\x03\x20\r\x0e\n\x0e\n\x07\x04\0\x04\0\t\0\x02\x12\x03\x20\r\x0e\
    \n\r\n\x06\x04\0\x04\0\t\x01\x12\x03\x20\x10\x11\n\x0e\n\x07\x04\0\x04\0\
    \t\x01\x01\x12\x03\x20\x10\x11\n\x0e\n\x07\x04\0\x04\0\t\x01\x02\x12\x03\
    \x20\x10\x11\n\r\n\x06\x04\0\x04\0\t\x02\x12\x03\x20\x13\x15\n\x0e\n\x07\
    \x04\0\x04\0\t\x02\x01\x12\x03\x20\x13\x15\n\x0e\n\x07\x04\0\x04\0\t\x02\
    \x02\x12\x03\x20\x13\x15\n\r\n\x06\x04\0\x04\0\t\x03\x12\x03\x20\x17\x19\
    \n\x0e\n\x07\x04\0\x04\0\t\x03\x01\x12\x03\x20\x17\x19\n\x0e\n\x07\x04\0\
    \x04\0\t\x03\x02\x12\x03\x20\x17\x19\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\
    \"\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03\"\x04\x0b\n\x0e\n\
    \x07\x04\0\x04\0\x02\0\x02\x12\x03\"\x0e\x0f\n\x96\x02\n\x06\x04\0\x04\0\
    \x02\x01\x12\x03.\x04\x0e\x1a\x86\x02\x20Redis\x20stores\x20a\x20Feature\
    Row\x20element\x20as\x20a\x20key,\x20value\x20pair.\n\n\x20The\x20Redis\
    \x20data\x20types\x20used\x20(https://redis.io/topics/data-types):\n\x20\
    -\x20key:\x20STRING\n\x20-\x20value:\x20STRING\n\x20\n\x20Encodings:\n\
    \x20-\x20key:\x20byte\x20array\x20of\x20RedisKey\x20(refer\x20to\x20feas\
    t.storage.RedisKeyV2)\n\x20-\x20value:\x20Redis\x20hashmap\n\x20\n\n\x0e\
    \n\x07\x04\0\x04\0\x02\x01\x01\x12\x03.\x04\t\n\x0e\n\x07\x04\0\x04\0\
    \x02\x01\x02\x12\x03.\x0c\r\n\r\n\x06\x04\0\x04\0\x02\x02\x12\x030\x04\
    \x16\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x030\x04\x11\n\x0e\n\x07\
    \x04\0\x04\0\x02\x02\x02\x12\x030\x14\x15\n\x0c\n\x04\x04\0\x03\0\x12\
    \x043\x02?\x03\n\x0c\n\x05\x04\0\x03\0\x01\x12\x033\n\x15\n\r\n\x06\x04\
    \0\x03\0\x02\0\x12\x034\x04\x14\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\
    \x034\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x034\x0b\x0f\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x03\x12\x034\x12\x13\n\r\n\x06\x04\0\x03\0\x02\
    \x01\x12\x035\x04\x13\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x035\x04\t\
    \n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x035\n\x0e\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x035\x11\x12\n\xd3\x01\n\x06\x04\0\x03\0\x02\x02\
    \x12\x038\x04!\x1a\xc3\x01\x20Optional.\x20The\x20number\x20of\x20millis\
    econds\x20to\x20wait\x20before\x20retrying\x20failed\x20Redis\x20connect\
    ion.\n\x20By\x20default,\x20Feast\x20uses\x20exponential\x20backoff\x20p\
    olicy\x20and\x20\"initial_backoff_ms\"\x20sets\x20the\x20initial\x20wait\
    \x20duration.\n\n\x0e\n\x07\x04\0\x03\0\x02\x02\x05\x12\x038\x04\t\n\x0e\
    \n\x07\x04\0\x03\0\x02\x02\x01\x12\x038\n\x1c\n\x0e\n\x07\x04\0\x03\0\
    \x02\x02\x03\x12\x038\x1f\x20\nl\n\x06\x04\0\x03\0\x02\x03\x12\x03:\x04\
    \x1a\x1a]\x20Optional.\x20Maximum\x20total\x20number\x20of\x20retries\
    \x20for\x20connecting\x20to\x20Redis.\x20Default\x20to\x20zero\x20retrie\
    s.\n\n\x0e\n\x07\x04\0\x03\0\x02\x03\x05\x12\x03:\x04\t\n\x0e\n\x07\x04\
    \0\x03\0\x02\x03\x01\x12\x03:\n\x15\n\x0e\n\x07\x04\0\x03\0\x02\x03\x03\
    \x12\x03:\x18\x19\n8\n\x06\x04\0\x03\0\x02\x04\x12\x03<\x04&\x1a)\x20Opt\
    ional.\x20How\x20often\x20flush\x20data\x20to\x20redis\n\n\x0e\n\x07\x04\
    \0\x03\0\x02\x04\x05\x12\x03<\x04\t\n\x0e\n\x07\x04\0\x03\0\x02\x04\x01\
    \x12\x03<\n!\n\x0e\n\x07\x04\0\x03\0\x02\x04\x03\x12\x03<$%\n,\n\x06\x04\
    \0\x03\0\x02\x05\x12\x03>\x04\x11\x1a\x1d\x20Optional.\x20Connect\x20ove\
    r\x20SSL.\n\n\x0e\n\x07\x04\0\x03\0\x02\x05\x05\x12\x03>\x04\x08\n\x0e\n\
    \x07\x04\0\x03\0\x02\x05\x01\x12\x03>\t\x0c\n\x0e\n\x07\x04\0\x03\0\x02\
    \x05\x03\x12\x03>\x0f\x10\n\x0c\n\x04\x04\0\x03\x01\x12\x04A\x02X\x03\n\
    \x0c\n\x05\x04\0\x03\x01\x01\x12\x03A\n\x1c\nr\n\x06\x04\0\x03\x01\x02\0\
    \x12\x03C\x04!\x1ac\x20List\x20of\x20Redis\x20Uri\x20for\x20all\x20the\
    \x20nodes\x20in\x20Redis\x20Cluster,\x20comma\x20separated.\x20Eg.\x20ho\
    st1:6379,\x20host2:6379\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x03C\
    \x04\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\x03C\x0b\x1c\n\x0e\n\x07\
    \x04\0\x03\x01\x02\0\x03\x12\x03C\x1f\x20\n\r\n\x06\x04\0\x03\x01\x02\
    \x01\x12\x03D\x04!\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x05\x12\x03D\x04\t\
    \n\x0e\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x03D\n\x1c\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x01\x03\x12\x03D\x1f\x20\n\r\n\x06\x04\0\x03\x01\x02\x02\
    \x12\x03E\x04\x1a\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x05\x12\x03E\x04\t\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x03E\n\x15\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x02\x03\x12\x03E\x18\x19\n8\n\x06\x04\0\x03\x01\x02\x03\x12\
    \x03G\x04&\x1a)\x20Optional.\x20How\x20often\x20flush\x20data\x20to\x20r\
    edis\n\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x05\x12\x03G\x04\t\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x03\x01\x12\x03G\n!\n\x0e\n\x07\x04\0\x03\x01\x02\x03\
    \x03\x12\x03G$%\n;\n\x06\x04\0\x03\x01\x02\x04\x12\x03I\x04\x1a\x1a,\x20\
    Optional.\x20Append\x20a\x20prefix\x20to\x20the\x20Redis\x20Key\n\n\x0e\
    \n\x07\x04\0\x03\x01\x02\x04\x05\x12\x03I\x04\n\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x04\x01\x12\x03I\x0b\x15\n\x0e\n\x07\x04\0\x03\x01\x02\x04\x03\
    \x12\x03I\x18\x19\n\xb1\x01\n\x06\x04\0\x03\x01\x02\x05\x12\x03L\x04\x1d\
    \x1a\xa1\x01\x20Optional.\x20Enable\x20fallback\x20to\x20another\x20key\
    \x20prefix\x20if\x20the\x20original\x20key\x20is\x20not\x20present.\n\
    \x20Useful\x20for\x20migrating\x20key\x20prefix\x20without\x20re-ingesti\
    on.\x20Disabled\x20by\x20default.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x05\
    \x05\x12\x03L\x04\x08\n\x0e\n\x07\x04\0\x03\x01\x02\x05\x01\x12\x03L\t\
    \x18\n\x0e\n\x07\x04\0\x03\x01\x02\x05\x03\x12\x03L\x1b\x1c\n_\n\x06\x04\
    \0\x03\x01\x02\x06\x12\x03N\x04\x1f\x1aP\x20Optional.\x20This\x20would\
    \x20be\x20the\x20fallback\x20prefix\x20to\x20use\x20if\x20enable_fallbac\
    k\x20is\x20true.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x06\x05\x12\x03N\x04\n\
    \n\x0e\n\x07\x04\0\x03\x01\x02\x06\x01\x12\x03N\x0b\x1a\n\x0e\n\x07\x04\
    \0\x03\x01\x02\x06\x03\x12\x03N\x1d\x1e\nG\n\x06\x04\0\x03\x01\x04\0\x12\
    \x04Q\x04V\x05\x1a7\x20Optional.\x20Priority\x20of\x20nodes\x20when\x20r\
    eading\x20from\x20cluster\n\n\x0e\n\x07\x04\0\x03\x01\x04\0\x01\x12\x03Q\
    \t\x11\n\x0f\n\x08\x04\0\x03\x01\x04\0\x02\0\x12\x03R\x06\x11\n\x10\n\t\
    \x04\0\x03\x01\x04\0\x02\0\x01\x12\x03R\x06\x0c\n\x10\n\t\x04\0\x03\x01\
    \x04\0\x02\0\x02\x12\x03R\x0f\x10\n\x0f\n\x08\x04\0\x03\x01\x04\0\x02\
    \x01\x12\x03S\x06\x1b\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x01\x01\x12\x03S\
    \x06\x16\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x01\x02\x12\x03S\x19\x1a\n\
    \x0f\n\x08\x04\0\x03\x01\x04\0\x02\x02\x12\x03T\x06\x12\n\x10\n\t\x04\0\
    \x03\x01\x04\0\x02\x02\x01\x12\x03T\x06\r\n\x10\n\t\x04\0\x03\x01\x04\0\
    \x02\x02\x02\x12\x03T\x10\x11\n\x0f\n\x08\x04\0\x03\x01\x04\0\x02\x03\
    \x12\x03U\x06\x1c\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x03\x01\x12\x03U\x06\
    \x17\n\x10\n\t\x04\0\x03\x01\x04\0\x02\x03\x02\x12\x03U\x1a\x1b\n\r\n\
    \x06\x04\0\x03\x01\x02\x07\x12\x03W\x04\x1b\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x07\x06\x12\x03W\x04\x0c\n\x0e\n\x07\x04\0\x03\x01\x02\x07\x01\x12\
    \x03W\r\x16\n\x0e\n\x07\x04\0\x03\x01\x02\x07\x03\x12\x03W\x19\x1a\n\x0c\
    \n\x04\x04\0\x03\x02\x12\x04Z\x02q\x03\n\x0c\n\x05\x04\0\x03\x02\x01\x12\
    \x03Z\n\x16\n\xab\x02\n\x06\x04\0\x03\x02\x02\0\x12\x03a\x04\x17\x1a\x9b\
    \x02\x20Name\x20of\x20project\x20that\x20the\x20feature\x20sets\x20belon\
    gs\x20to.\x20This\x20can\x20be\x20one\x20of\n\x20-\x20[project_name]\n\
    \x20-\x20*\n\x20If\x20an\x20asterisk\x20is\x20provided,\x20filtering\x20\
    on\x20projects\x20will\x20be\x20disabled.\x20All\x20projects\x20will\n\
    \x20be\x20matched.\x20It\x20is\x20NOT\x20possible\x20to\x20provide\x20an\
    \x20asterisk\x20with\x20a\x20string\x20in\x20order\x20to\x20do\n\x20patt\
    ern\x20matching.\n\n\x0e\n\x07\x04\0\x03\x02\x02\0\x05\x12\x03a\x04\n\n\
    \x0e\n\x07\x04\0\x03\x02\x02\0\x01\x12\x03a\x0b\x12\n\x0e\n\x07\x04\0\
    \x03\x02\x02\0\x03\x12\x03a\x15\x16\n\x9f\x03\n\x06\x04\0\x03\x02\x02\
    \x01\x12\x03j\x04\x14\x1a\x8f\x03\x20Name\x20of\x20the\x20desired\x20fea\
    ture\x20set.\x20Asterisks\x20can\x20be\x20used\x20as\x20wildcards\x20in\
    \x20the\x20name.\n\x20Matching\x20on\x20names\x20is\x20only\x20permitted\
    \x20if\x20a\x20specific\x20project\x20is\x20defined.\x20It\x20is\x20disa\
    llowed\n\x20If\x20the\x20project\x20name\x20is\x20set\x20to\x20\"*\"\n\
    \x20e.g.\n\x20-\x20*\x20can\x20be\x20used\x20to\x20match\x20all\x20featu\
    re\x20sets\n\x20-\x20my-feature-set*\x20can\x20be\x20used\x20to\x20match\
    \x20all\x20features\x20prefixed\x20by\x20\"my-feature-set\"\n\x20-\x20my\
    -feature-set-6\x20can\x20be\x20used\x20to\x20select\x20a\x20single\x20fe\
    ature\x20set\n\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x05\x12\x03j\x04\n\n\
    \x0e\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x03j\x0b\x0f\n\x0e\n\x07\x04\0\
    \x03\x02\x02\x01\x03\x12\x03j\x12\x13\nW\n\x06\x04\0\x03\x02\x02\x02\x12\
    \x03m\x04\x15\x1aH\x20All\x20matches\x20with\x20exclude\x20enabled\x20wi\
    ll\x20be\x20filtered\x20out\x20instead\x20of\x20added\n\n\x0e\n\x07\x04\
    \0\x03\x02\x02\x02\x05\x12\x03m\x04\x08\n\x0e\n\x07\x04\0\x03\x02\x02\
    \x02\x01\x12\x03m\t\x10\n\x0e\n\x07\x04\0\x03\x02\x02\x02\x03\x12\x03m\
    \x13\x14\n:\n\x05\x04\0\x03\x02\t\x12\x03p\x04\x0f\x1a,\x20Feature\x20se\
    t\x20version\x20was\x20removed\x20in\x20v0.5.0.\n\n\r\n\x06\x04\0\x03\
    \x02\t\0\x12\x03p\r\x0e\n\x0e\n\x07\x04\0\x03\x02\t\0\x01\x12\x03p\r\x0e\
    \n\x0e\n\x07\x04\0\x03\x02\t\0\x02\x12\x03p\r\x0e\n!\n\x04\x04\0\x02\0\
    \x12\x03t\x02\x12\x1a\x14\x20Name\x20of\x20the\x20store.\n\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03t\t\
    \r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03t\x10\x11\n\x1d\n\x04\x04\0\x02\
    \x01\x12\x03w\x02\x15\x1a\x10\x20Type\x20of\x20store.\n\n\x0c\n\x05\x04\
    \0\x02\x01\x06\x12\x03w\x02\x0b\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03w\
    \x0c\x10\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03w\x13\x14\n,\n\x04\x04\0\
    \x02\x02\x12\x03z\x02*\x1a\x1f\x20Feature\x20sets\x20to\x20subscribe\x20\
    to.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03z\x02\n\n\x0c\n\x05\x04\0\x02\
    \x02\x06\x12\x03z\x0b\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03z\x18%\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03z()\nA\n\x04\x04\0\x08\0\x12\x05}\
    \x02\x80\x01\x03\x1a2\x20Configuration\x20to\x20connect\x20to\x20the\x20\
    store.\x20Required.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03}\x08\x0e\n\x0b\
    \n\x04\x04\0\x02\x03\x12\x03~\x04\"\n\x0c\n\x05\x04\0\x02\x03\x06\x12\
    \x03~\x04\x0f\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03~\x10\x1c\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03~\x1f!\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x7f\
    \x041\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x7f\x04\x16\n\x0c\n\x05\x04\
    \0\x02\x04\x01\x12\x03\x7f\x17+\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\
    \x7f.0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(Store::generated_message_descriptor_data());
            messages.push(store::RedisConfig::generated_message_descriptor_data());
            messages.push(store::RedisClusterConfig::generated_message_descriptor_data());
            messages.push(store::Subscription::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(store::StoreType::generated_enum_descriptor_data());
            enums.push(store::redis_cluster_config::ReadFrom::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
