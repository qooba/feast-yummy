// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/core/OnDemandFeatureView.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.OnDemandFeatureView)
pub struct OnDemandFeatureView {
    // message fields
    ///  User-specified specifications of this feature view.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureView.spec)
    pub spec: ::protobuf::MessageField<OnDemandFeatureViewSpec>,
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureView.meta)
    pub meta: ::protobuf::MessageField<OnDemandFeatureViewMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.OnDemandFeatureView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnDemandFeatureView {
    fn default() -> &'a OnDemandFeatureView {
        <OnDemandFeatureView as ::protobuf::Message>::default_instance()
    }
}

impl OnDemandFeatureView {
    pub fn new() -> OnDemandFeatureView {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OnDemandFeatureViewSpec>(
            "spec",
            |m: &OnDemandFeatureView| { &m.spec },
            |m: &mut OnDemandFeatureView| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OnDemandFeatureViewMeta>(
            "meta",
            |m: &OnDemandFeatureView| { &m.meta },
            |m: &mut OnDemandFeatureView| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnDemandFeatureView>(
            "OnDemandFeatureView",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnDemandFeatureView {
    const NAME: &'static str = "OnDemandFeatureView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnDemandFeatureView {
        OnDemandFeatureView::new()
    }

    fn clear(&mut self) {
        self.spec.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnDemandFeatureView {
        static instance: OnDemandFeatureView = OnDemandFeatureView {
            spec: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnDemandFeatureView {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnDemandFeatureView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnDemandFeatureView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnDemandFeatureView {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Next available id: 9
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.OnDemandFeatureViewSpec)
pub struct OnDemandFeatureViewSpec {
    // message fields
    ///  Name of the feature view. Must be unique. Not updated.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.name)
    pub name: ::std::string::String,
    ///  Name of Feast project that this feature view belongs to.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.project)
    pub project: ::std::string::String,
    ///  List of features specifications for each feature defined with this feature view.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.features)
    pub features: ::std::vec::Vec<super::Feature::FeatureSpecV2>,
    ///  Map of sources for this feature view.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.sources)
    pub sources: ::std::collections::HashMap<::std::string::String, OnDemandSource>,
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.user_defined_function)
    pub user_defined_function: ::protobuf::MessageField<UserDefinedFunction>,
    ///  Description of the on demand feature view.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.description)
    pub description: ::std::string::String,
    ///  User defined metadata.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.tags)
    pub tags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Owner of the on demand feature view.
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewSpec.owner)
    pub owner: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.OnDemandFeatureViewSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnDemandFeatureViewSpec {
    fn default() -> &'a OnDemandFeatureViewSpec {
        <OnDemandFeatureViewSpec as ::protobuf::Message>::default_instance()
    }
}

impl OnDemandFeatureViewSpec {
    pub fn new() -> OnDemandFeatureViewSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &OnDemandFeatureViewSpec| { &m.name },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &OnDemandFeatureViewSpec| { &m.project },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &OnDemandFeatureViewSpec| { &m.features },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "sources",
            |m: &OnDemandFeatureViewSpec| { &m.sources },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserDefinedFunction>(
            "user_defined_function",
            |m: &OnDemandFeatureViewSpec| { &m.user_defined_function },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.user_defined_function },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &OnDemandFeatureViewSpec| { &m.description },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "tags",
            |m: &OnDemandFeatureViewSpec| { &m.tags },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner",
            |m: &OnDemandFeatureViewSpec| { &m.owner },
            |m: &mut OnDemandFeatureViewSpec| { &mut m.owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnDemandFeatureViewSpec>(
            "OnDemandFeatureViewSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnDemandFeatureViewSpec {
    const NAME: &'static str = "OnDemandFeatureViewSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.project = is.read_string()?;
                },
                26 => {
                    self.features.push(is.read_message()?);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.sources.insert(key, value);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_defined_function)?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.tags.insert(key, value);
                },
                66 => {
                    self.owner = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project);
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.sources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.user_defined_function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.owner);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.project.is_empty() {
            os.write_string(2, &self.project)?;
        }
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for (k, v) in &self.sources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.user_defined_function.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.owner.is_empty() {
            os.write_string(8, &self.owner)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnDemandFeatureViewSpec {
        OnDemandFeatureViewSpec::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.project.clear();
        self.features.clear();
        self.sources.clear();
        self.user_defined_function.clear();
        self.description.clear();
        self.tags.clear();
        self.owner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnDemandFeatureViewSpec {
        static instance: ::protobuf::rt::Lazy<OnDemandFeatureViewSpec> = ::protobuf::rt::Lazy::new();
        instance.get(OnDemandFeatureViewSpec::new)
    }
}

impl ::protobuf::MessageFull for OnDemandFeatureViewSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnDemandFeatureViewSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnDemandFeatureViewSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnDemandFeatureViewSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.OnDemandFeatureViewMeta)
pub struct OnDemandFeatureViewMeta {
    // message fields
    ///  Time where this Feature View is created
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewMeta.created_timestamp)
    pub created_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Time where this Feature View is last updated
    // @@protoc_insertion_point(field:feast.core.OnDemandFeatureViewMeta.last_updated_timestamp)
    pub last_updated_timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.OnDemandFeatureViewMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnDemandFeatureViewMeta {
    fn default() -> &'a OnDemandFeatureViewMeta {
        <OnDemandFeatureViewMeta as ::protobuf::Message>::default_instance()
    }
}

impl OnDemandFeatureViewMeta {
    pub fn new() -> OnDemandFeatureViewMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_timestamp",
            |m: &OnDemandFeatureViewMeta| { &m.created_timestamp },
            |m: &mut OnDemandFeatureViewMeta| { &mut m.created_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "last_updated_timestamp",
            |m: &OnDemandFeatureViewMeta| { &m.last_updated_timestamp },
            |m: &mut OnDemandFeatureViewMeta| { &mut m.last_updated_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnDemandFeatureViewMeta>(
            "OnDemandFeatureViewMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnDemandFeatureViewMeta {
    const NAME: &'static str = "OnDemandFeatureViewMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_timestamp)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_updated_timestamp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.created_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_updated_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.created_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.last_updated_timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnDemandFeatureViewMeta {
        OnDemandFeatureViewMeta::new()
    }

    fn clear(&mut self) {
        self.created_timestamp.clear();
        self.last_updated_timestamp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnDemandFeatureViewMeta {
        static instance: OnDemandFeatureViewMeta = OnDemandFeatureViewMeta {
            created_timestamp: ::protobuf::MessageField::none(),
            last_updated_timestamp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnDemandFeatureViewMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnDemandFeatureViewMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnDemandFeatureViewMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnDemandFeatureViewMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.OnDemandSource)
pub struct OnDemandSource {
    // message oneof groups
    pub source: ::std::option::Option<on_demand_source::Source>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.OnDemandSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnDemandSource {
    fn default() -> &'a OnDemandSource {
        <OnDemandSource as ::protobuf::Message>::default_instance()
    }
}

impl OnDemandSource {
    pub fn new() -> OnDemandSource {
        ::std::default::Default::default()
    }

    // .feast.core.FeatureView feature_view = 1;

    pub fn feature_view(&self) -> &super::FeatureView::FeatureView {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureView(ref v)) => v,
            _ => <super::FeatureView::FeatureView as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_feature_view(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_feature_view(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureView(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_feature_view(&mut self, v: super::FeatureView::FeatureView) {
        self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureView(v))
    }

    // Mutable pointer to the field.
    pub fn mut_feature_view(&mut self) -> &mut super::FeatureView::FeatureView {
        if let ::std::option::Option::Some(on_demand_source::Source::FeatureView(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureView(super::FeatureView::FeatureView::new()));
        }
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureView(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_feature_view(&mut self) -> super::FeatureView::FeatureView {
        if self.has_feature_view() {
            match self.source.take() {
                ::std::option::Option::Some(on_demand_source::Source::FeatureView(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FeatureView::FeatureView::new()
        }
    }

    // .feast.core.FeatureViewProjection feature_view_projection = 3;

    pub fn feature_view_projection(&self) -> &super::FeatureViewProjection::FeatureViewProjection {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(ref v)) => v,
            _ => <super::FeatureViewProjection::FeatureViewProjection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_feature_view_projection(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_feature_view_projection(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_feature_view_projection(&mut self, v: super::FeatureViewProjection::FeatureViewProjection) {
        self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_feature_view_projection(&mut self) -> &mut super::FeatureViewProjection::FeatureViewProjection {
        if let ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(super::FeatureViewProjection::FeatureViewProjection::new()));
        }
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_feature_view_projection(&mut self) -> super::FeatureViewProjection::FeatureViewProjection {
        if self.has_feature_view_projection() {
            match self.source.take() {
                ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FeatureViewProjection::FeatureViewProjection::new()
        }
    }

    // .feast.core.DataSource request_data_source = 2;

    pub fn request_data_source(&self) -> &super::DataSource::DataSource {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(ref v)) => v,
            _ => <super::DataSource::DataSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_request_data_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_request_data_source(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_data_source(&mut self, v: super::DataSource::DataSource) {
        self.source = ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_data_source(&mut self) -> &mut super::DataSource::DataSource {
        if let ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(super::DataSource::DataSource::new()));
        }
        match self.source {
            ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_data_source(&mut self) -> super::DataSource::DataSource {
        if self.has_request_data_source() {
            match self.source.take() {
                ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(v)) => v,
                _ => panic!(),
            }
        } else {
            super::DataSource::DataSource::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FeatureView::FeatureView>(
            "feature_view",
            OnDemandSource::has_feature_view,
            OnDemandSource::feature_view,
            OnDemandSource::mut_feature_view,
            OnDemandSource::set_feature_view,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FeatureViewProjection::FeatureViewProjection>(
            "feature_view_projection",
            OnDemandSource::has_feature_view_projection,
            OnDemandSource::feature_view_projection,
            OnDemandSource::mut_feature_view_projection,
            OnDemandSource::set_feature_view_projection,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DataSource::DataSource>(
            "request_data_source",
            OnDemandSource::has_request_data_source,
            OnDemandSource::request_data_source,
            OnDemandSource::mut_request_data_source,
            OnDemandSource::set_request_data_source,
        ));
        oneofs.push(on_demand_source::Source::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnDemandSource>(
            "OnDemandSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnDemandSource {
    const NAME: &'static str = "OnDemandSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureView(is.read_message()?));
                },
                26 => {
                    self.source = ::std::option::Option::Some(on_demand_source::Source::FeatureViewProjection(is.read_message()?));
                },
                18 => {
                    self.source = ::std::option::Option::Some(on_demand_source::Source::RequestDataSource(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &on_demand_source::Source::FeatureView(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &on_demand_source::Source::FeatureViewProjection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &on_demand_source::Source::RequestDataSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &on_demand_source::Source::FeatureView(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &on_demand_source::Source::FeatureViewProjection(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &on_demand_source::Source::RequestDataSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnDemandSource {
        OnDemandSource::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnDemandSource {
        static instance: OnDemandSource = OnDemandSource {
            source: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnDemandSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnDemandSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnDemandSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnDemandSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OnDemandSource`
pub mod on_demand_source {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.core.OnDemandSource.source)
    pub enum Source {
        // @@protoc_insertion_point(oneof_field:feast.core.OnDemandSource.feature_view)
        FeatureView(super::super::FeatureView::FeatureView),
        // @@protoc_insertion_point(oneof_field:feast.core.OnDemandSource.feature_view_projection)
        FeatureViewProjection(super::super::FeatureViewProjection::FeatureViewProjection),
        // @@protoc_insertion_point(oneof_field:feast.core.OnDemandSource.request_data_source)
        RequestDataSource(super::super::DataSource::DataSource),
    }

    impl ::protobuf::Oneof for Source {
    }

    impl ::protobuf::OneofFull for Source {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::OnDemandSource as ::protobuf::MessageFull>::descriptor().oneof_by_name("source").unwrap()).clone()
        }
    }

    impl Source {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Source>("source")
        }
    }
}

///  Serialized representation of python function.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.UserDefinedFunction)
pub struct UserDefinedFunction {
    // message fields
    ///  The function name
    // @@protoc_insertion_point(field:feast.core.UserDefinedFunction.name)
    pub name: ::std::string::String,
    ///  The python-syntax function body (serialized by dill)
    // @@protoc_insertion_point(field:feast.core.UserDefinedFunction.body)
    pub body: ::std::vec::Vec<u8>,
    ///  The string representation of the udf
    // @@protoc_insertion_point(field:feast.core.UserDefinedFunction.body_text)
    pub body_text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.UserDefinedFunction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDefinedFunction {
    fn default() -> &'a UserDefinedFunction {
        <UserDefinedFunction as ::protobuf::Message>::default_instance()
    }
}

impl UserDefinedFunction {
    pub fn new() -> UserDefinedFunction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UserDefinedFunction| { &m.name },
            |m: &mut UserDefinedFunction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &UserDefinedFunction| { &m.body },
            |m: &mut UserDefinedFunction| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body_text",
            |m: &UserDefinedFunction| { &m.body_text },
            |m: &mut UserDefinedFunction| { &mut m.body_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDefinedFunction>(
            "UserDefinedFunction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDefinedFunction {
    const NAME: &'static str = "UserDefinedFunction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.body = is.read_bytes()?;
                },
                26 => {
                    self.body_text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.body);
        }
        if !self.body_text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.body_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.body.is_empty() {
            os.write_bytes(2, &self.body)?;
        }
        if !self.body_text.is_empty() {
            os.write_string(3, &self.body_text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDefinedFunction {
        UserDefinedFunction::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.body.clear();
        self.body_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDefinedFunction {
        static instance: UserDefinedFunction = UserDefinedFunction {
            name: ::std::string::String::new(),
            body: ::std::vec::Vec::new(),
            body_text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDefinedFunction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDefinedFunction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDefinedFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDefinedFunction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$feast/core/OnDemandFeatureView.proto\x12\nfeast.core\x1a\x1fgoogle/pr\
    otobuf/timestamp.proto\x1a\x1cfeast/core/FeatureView.proto\x1a&feast/cor\
    e/FeatureViewProjection.proto\x1a\x18feast/core/Feature.proto\x1a\x1bfea\
    st/core/DataSource.proto\"\x87\x01\n\x13OnDemandFeatureView\x127\n\x04sp\
    ec\x18\x01\x20\x01(\x0b2#.feast.core.OnDemandFeatureViewSpecR\x04spec\
    \x127\n\x04meta\x18\x02\x20\x01(\x0b2#.feast.core.OnDemandFeatureViewMet\
    aR\x04meta\"\xab\x04\n\x17OnDemandFeatureViewSpec\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x18\n\x07project\x18\x02\x20\x01(\tR\x07pro\
    ject\x125\n\x08features\x18\x03\x20\x03(\x0b2\x19.feast.core.FeatureSpec\
    V2R\x08features\x12J\n\x07sources\x18\x04\x20\x03(\x0b20.feast.core.OnDe\
    mandFeatureViewSpec.SourcesEntryR\x07sources\x12S\n\x15user_defined_func\
    tion\x18\x05\x20\x01(\x0b2\x1f.feast.core.UserDefinedFunctionR\x13userDe\
    finedFunction\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescriptio\
    n\x12A\n\x04tags\x18\x07\x20\x03(\x0b2-.feast.core.OnDemandFeatureViewSp\
    ec.TagsEntryR\x04tags\x12\x14\n\x05owner\x18\x08\x20\x01(\tR\x05owner\
    \x1aV\n\x0cSourcesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x120\
    \n\x05value\x18\x02\x20\x01(\x0b2\x1a.feast.core.OnDemandSourceR\x05valu\
    e:\x028\x01\x1a7\n\tTagsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb4\x01\n\
    \x17OnDemandFeatureViewMeta\x12G\n\x11created_timestamp\x18\x01\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x10createdTimestamp\x12P\n\x16last_\
    updated_timestamp\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x14lastUpdatedTimestamp\"\xff\x01\n\x0eOnDemandSource\x12<\n\x0cfeature\
    _view\x18\x01\x20\x01(\x0b2\x17.feast.core.FeatureViewH\0R\x0bfeatureVie\
    w\x12[\n\x17feature_view_projection\x18\x03\x20\x01(\x0b2!.feast.core.Fe\
    atureViewProjectionH\0R\x15featureViewProjection\x12H\n\x13request_data_\
    source\x18\x02\x20\x01(\x0b2\x16.feast.core.DataSourceH\0R\x11requestDat\
    aSourceB\x08\n\x06source\"Z\n\x13UserDefinedFunction\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04body\x18\x02\x20\x01(\x0cR\x04\
    body\x12\x1b\n\tbody_text\x18\x03\x20\x01(\tR\x08bodyTextB]\n\x10feast.p\
    roto.coreB\x18OnDemandFeatureViewProtoZ/github.com/feast-dev/feast/go/pr\
    otos/feast/coreJ\x84\x14\n\x06\x12\x04\x11\0X\x01\n\xc6\x04\n\x01\x0c\
    \x12\x03\x11\0\x122\xbb\x04\n\x20Copyright\x202020\x20The\x20Feast\x20Au\
    thors\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\
    \x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20Y\
    ou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\
    \x20\x20\x20\x20https://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unles\
    s\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20\
    writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WA\
    RRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\
    \x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x12\0\x13\n\x08\n\x01\
    \x08\x12\x03\x14\0F\n\t\n\x02\x08\x0b\x12\x03\x14\0F\n\x08\n\x01\x08\x12\
    \x03\x15\09\n\t\n\x02\x08\x08\x12\x03\x15\09\n\x08\n\x01\x08\x12\x03\x16\
    \0)\n\t\n\x02\x08\x01\x12\x03\x16\0)\n\t\n\x02\x03\0\x12\x03\x18\0)\n\t\
    \n\x02\x03\x01\x12\x03\x19\0&\n\t\n\x02\x03\x02\x12\x03\x1a\00\n\t\n\x02\
    \x03\x03\x12\x03\x1b\0\"\n\t\n\x02\x03\x04\x12\x03\x1c\0%\n\n\n\x02\x04\
    \0\x12\x04\x1e\0\"\x01\n\n\n\x03\x04\0\x01\x12\x03\x1e\x08\x1b\nB\n\x04\
    \x04\0\x02\0\x12\x03\x20\x04%\x1a5\x20User-specified\x20specifications\
    \x20of\x20this\x20feature\x20view.\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\
    \x20\x04\x1b\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x20\x1c\x20\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x20#$\n\x0b\n\x04\x04\0\x02\x01\x12\x03!\x04%\n\
    \x0c\n\x05\x04\0\x02\x01\x06\x12\x03!\x04\x1b\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03!\x1c\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03!#$\n\"\n\x02\
    \x04\x01\x12\x04%\0<\x01\x1a\x16\x20Next\x20available\x20id:\x209\n\n\n\
    \n\x03\x04\x01\x01\x12\x03%\x08\x1f\nE\n\x04\x04\x01\x02\0\x12\x03'\x04\
    \x14\x1a8\x20Name\x20of\x20the\x20feature\x20view.\x20Must\x20be\x20uniq\
    ue.\x20Not\x20updated.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03'\x04\n\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03'\x0b\x0f\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03'\x12\x13\nG\n\x04\x04\x01\x02\x01\x12\x03*\x04\x17\x1a:\x20\
    Name\x20of\x20Feast\x20project\x20that\x20this\x20feature\x20view\x20bel\
    ongs\x20to.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03*\x04\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03*\x0b\x12\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03*\x15\x16\n_\n\x04\x04\x01\x02\x02\x12\x03-\x04(\x1aR\x20List\
    \x20of\x20features\x20specifications\x20for\x20each\x20feature\x20define\
    d\x20with\x20this\x20feature\x20view.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03-\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03-\r\x1a\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03-\x1b#\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03-&'\n4\n\x04\x04\x01\x02\x03\x12\x030\x04,\x1a'\x20Map\x20of\x20\
    sources\x20for\x20this\x20feature\x20view.\n\n\x0c\n\x05\x04\x01\x02\x03\
    \x06\x12\x030\x04\x1f\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x030\x20'\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x030*+\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x032\x042\n\x0c\n\x05\x04\x01\x02\x04\x06\x12\x032\x04\x17\n\x0c\n\
    \x05\x04\x01\x02\x04\x01\x12\x032\x18-\n\x0c\n\x05\x04\x01\x02\x04\x03\
    \x12\x03201\n9\n\x04\x04\x01\x02\x05\x12\x035\x04\x1b\x1a,\x20Descriptio\
    n\x20of\x20the\x20on\x20demand\x20feature\x20view.\n\n\x0c\n\x05\x04\x01\
    \x02\x05\x05\x12\x035\x04\n\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x035\x0b\
    \x16\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x035\x19\x1a\n%\n\x04\x04\x01\
    \x02\x06\x12\x038\x04\x20\x1a\x18\x20User\x20defined\x20metadata.\n\n\
    \x0c\n\x05\x04\x01\x02\x06\x06\x12\x038\x04\x16\n\x0c\n\x05\x04\x01\x02\
    \x06\x01\x12\x038\x17\x1b\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x038\x1e\
    \x1f\n3\n\x04\x04\x01\x02\x07\x12\x03;\x04\x15\x1a&\x20Owner\x20of\x20th\
    e\x20on\x20demand\x20feature\x20view.\n\n\x0c\n\x05\x04\x01\x02\x07\x05\
    \x12\x03;\x04\n\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03;\x0b\x10\n\x0c\n\
    \x05\x04\x01\x02\x07\x03\x12\x03;\x13\x14\n\n\n\x02\x04\x02\x12\x04>\0D\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03>\x08\x1f\n6\n\x04\x04\x02\x02\0\x12\
    \x03@\x044\x1a)\x20Time\x20where\x20this\x20Feature\x20View\x20is\x20cre\
    ated\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03@\x04\x1d\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03@\x1e/\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03@23\n;\
    \n\x04\x04\x02\x02\x01\x12\x03C\x049\x1a.\x20Time\x20where\x20this\x20Fe\
    ature\x20View\x20is\x20last\x20updated\n\n\x0c\n\x05\x04\x02\x02\x01\x06\
    \x12\x03C\x04\x1d\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03C\x1e4\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03C78\n\n\n\x02\x04\x03\x12\x04F\0L\x01\n\
    \n\n\x03\x04\x03\x01\x12\x03F\x08\x16\n\x0c\n\x04\x04\x03\x08\0\x12\x04G\
    \x04K\x05\n\x0c\n\x05\x04\x03\x08\0\x01\x12\x03G\n\x10\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03H\x08%\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03H\x08\x13\
    \n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03H\x14\x20\n\x0c\n\x05\x04\x03\x02\
    \0\x03\x12\x03H#$\n\x0b\n\x04\x04\x03\x02\x01\x12\x03I\x08:\n\x0c\n\x05\
    \x04\x03\x02\x01\x06\x12\x03I\x08\x1d\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03I\x1e5\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03I89\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03J\x08+\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03J\
    \x08\x12\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03J\x13&\n\x0c\n\x05\x04\
    \x03\x02\x02\x03\x12\x03J)*\n;\n\x02\x04\x04\x12\x04O\0X\x01\x1a/\x20Ser\
    ialized\x20representation\x20of\x20python\x20function.\n\n\n\n\x03\x04\
    \x04\x01\x12\x03O\x08\x1b\n\x20\n\x04\x04\x04\x02\0\x12\x03Q\x04\x14\x1a\
    \x13\x20The\x20function\x20name\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03Q\
    \x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03Q\x0b\x0f\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03Q\x12\x13\nC\n\x04\x04\x04\x02\x01\x12\x03T\x04\
    \x13\x1a6\x20The\x20python-syntax\x20function\x20body\x20(serialized\x20\
    by\x20dill)\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03T\x04\t\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03T\n\x0e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03T\x11\x12\n3\n\x04\x04\x04\x02\x02\x12\x03W\x04\x19\x1a&\x20The\x20s\
    tring\x20representation\x20of\x20the\x20udf\n\n\x0c\n\x05\x04\x04\x02\
    \x02\x05\x12\x03W\x04\n\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03W\x0b\x14\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03W\x17\x18b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::FeatureView::file_descriptor().clone());
            deps.push(super::FeatureViewProjection::file_descriptor().clone());
            deps.push(super::Feature::file_descriptor().clone());
            deps.push(super::DataSource::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(OnDemandFeatureView::generated_message_descriptor_data());
            messages.push(OnDemandFeatureViewSpec::generated_message_descriptor_data());
            messages.push(OnDemandFeatureViewMeta::generated_message_descriptor_data());
            messages.push(OnDemandSource::generated_message_descriptor_data());
            messages.push(UserDefinedFunction::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
