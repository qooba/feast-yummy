// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/types/Value.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.ValueType)
pub struct ValueType {
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.ValueType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueType {
    fn default() -> &'a ValueType {
        <ValueType as ::protobuf::Message>::default_instance()
    }
}

impl ValueType {
    pub fn new() -> ValueType {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueType>(
            "ValueType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueType {
    const NAME: &'static str = "ValueType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueType {
        ValueType::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueType {
        static instance: ValueType = ValueType {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ValueType`
pub mod value_type {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:feast.types.ValueType.Enum)
    pub enum Enum {
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.BYTES)
        BYTES = 1,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.STRING)
        STRING = 2,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.INT32)
        INT32 = 3,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.INT64)
        INT64 = 4,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.DOUBLE)
        DOUBLE = 5,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.FLOAT)
        FLOAT = 6,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.BOOL)
        BOOL = 7,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.UNIX_TIMESTAMP)
        UNIX_TIMESTAMP = 8,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.BYTES_LIST)
        BYTES_LIST = 11,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.STRING_LIST)
        STRING_LIST = 12,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.INT32_LIST)
        INT32_LIST = 13,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.INT64_LIST)
        INT64_LIST = 14,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.DOUBLE_LIST)
        DOUBLE_LIST = 15,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.FLOAT_LIST)
        FLOAT_LIST = 16,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.BOOL_LIST)
        BOOL_LIST = 17,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.UNIX_TIMESTAMP_LIST)
        UNIX_TIMESTAMP_LIST = 18,
        // @@protoc_insertion_point(enum_value:feast.types.ValueType.Enum.NULL)
        NULL = 19,
    }

    impl ::protobuf::Enum for Enum {
        const NAME: &'static str = "Enum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enum> {
            match value {
                0 => ::std::option::Option::Some(Enum::INVALID),
                1 => ::std::option::Option::Some(Enum::BYTES),
                2 => ::std::option::Option::Some(Enum::STRING),
                3 => ::std::option::Option::Some(Enum::INT32),
                4 => ::std::option::Option::Some(Enum::INT64),
                5 => ::std::option::Option::Some(Enum::DOUBLE),
                6 => ::std::option::Option::Some(Enum::FLOAT),
                7 => ::std::option::Option::Some(Enum::BOOL),
                8 => ::std::option::Option::Some(Enum::UNIX_TIMESTAMP),
                11 => ::std::option::Option::Some(Enum::BYTES_LIST),
                12 => ::std::option::Option::Some(Enum::STRING_LIST),
                13 => ::std::option::Option::Some(Enum::INT32_LIST),
                14 => ::std::option::Option::Some(Enum::INT64_LIST),
                15 => ::std::option::Option::Some(Enum::DOUBLE_LIST),
                16 => ::std::option::Option::Some(Enum::FLOAT_LIST),
                17 => ::std::option::Option::Some(Enum::BOOL_LIST),
                18 => ::std::option::Option::Some(Enum::UNIX_TIMESTAMP_LIST),
                19 => ::std::option::Option::Some(Enum::NULL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enum] = &[
            Enum::INVALID,
            Enum::BYTES,
            Enum::STRING,
            Enum::INT32,
            Enum::INT64,
            Enum::DOUBLE,
            Enum::FLOAT,
            Enum::BOOL,
            Enum::UNIX_TIMESTAMP,
            Enum::BYTES_LIST,
            Enum::STRING_LIST,
            Enum::INT32_LIST,
            Enum::INT64_LIST,
            Enum::DOUBLE_LIST,
            Enum::FLOAT_LIST,
            Enum::BOOL_LIST,
            Enum::UNIX_TIMESTAMP_LIST,
            Enum::NULL,
        ];
    }

    impl ::protobuf::EnumFull for Enum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ValueType.Enum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Enum::INVALID => 0,
                Enum::BYTES => 1,
                Enum::STRING => 2,
                Enum::INT32 => 3,
                Enum::INT64 => 4,
                Enum::DOUBLE => 5,
                Enum::FLOAT => 6,
                Enum::BOOL => 7,
                Enum::UNIX_TIMESTAMP => 8,
                Enum::BYTES_LIST => 9,
                Enum::STRING_LIST => 10,
                Enum::INT32_LIST => 11,
                Enum::INT64_LIST => 12,
                Enum::DOUBLE_LIST => 13,
                Enum::FLOAT_LIST => 14,
                Enum::BOOL_LIST => 15,
                Enum::UNIX_TIMESTAMP_LIST => 16,
                Enum::NULL => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enum {
        fn default() -> Self {
            Enum::INVALID
        }
    }

    impl Enum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enum>("ValueType.Enum")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.Value)
pub struct Value {
    // message oneof groups
    pub val: ::std::option::Option<value::Val>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.Value.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Value {
    fn default() -> &'a Value {
        <Value as ::protobuf::Message>::default_instance()
    }
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // bytes bytes_val = 1;

    pub fn bytes_val(&self) -> &[u8] {
        match self.val {
            ::std::option::Option::Some(value::Val::BytesVal(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_bytes_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_bytes_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::BytesVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = ::std::option::Option::Some(value::Val::BytesVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(value::Val::BytesVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::BytesVal(::std::vec::Vec::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::BytesVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_val(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_bytes_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::BytesVal(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // string string_val = 2;

    pub fn string_val(&self) -> &str {
        match self.val {
            ::std::option::Option::Some(value::Val::StringVal(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_string_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::StringVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_val(&mut self, v: ::std::string::String) {
        self.val = ::std::option::Option::Some(value::Val::StringVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_val(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(value::Val::StringVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::StringVal(::std::string::String::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::StringVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_val(&mut self) -> ::std::string::String {
        if self.has_string_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::StringVal(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 int32_val = 3;

    pub fn int32_val(&self) -> i32 {
        match self.val {
            ::std::option::Option::Some(value::Val::Int32Val(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int32_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_int32_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::Int32Val(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int32_val(&mut self, v: i32) {
        self.val = ::std::option::Option::Some(value::Val::Int32Val(v))
    }

    // int64 int64_val = 4;

    pub fn int64_val(&self) -> i64 {
        match self.val {
            ::std::option::Option::Some(value::Val::Int64Val(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int64_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_int64_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::Int64Val(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64_val(&mut self, v: i64) {
        self.val = ::std::option::Option::Some(value::Val::Int64Val(v))
    }

    // double double_val = 5;

    pub fn double_val(&self) -> f64 {
        match self.val {
            ::std::option::Option::Some(value::Val::DoubleVal(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_double_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::DoubleVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_val(&mut self, v: f64) {
        self.val = ::std::option::Option::Some(value::Val::DoubleVal(v))
    }

    // float float_val = 6;

    pub fn float_val(&self) -> f32 {
        match self.val {
            ::std::option::Option::Some(value::Val::FloatVal(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_float_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::FloatVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_val(&mut self, v: f32) {
        self.val = ::std::option::Option::Some(value::Val::FloatVal(v))
    }

    // bool bool_val = 7;

    pub fn bool_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::BoolVal(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_bool_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::BoolVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_val(&mut self, v: bool) {
        self.val = ::std::option::Option::Some(value::Val::BoolVal(v))
    }

    // int64 unix_timestamp_val = 8;

    pub fn unix_timestamp_val(&self) -> i64 {
        match self.val {
            ::std::option::Option::Some(value::Val::UnixTimestampVal(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_unix_timestamp_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_unix_timestamp_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::UnixTimestampVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unix_timestamp_val(&mut self, v: i64) {
        self.val = ::std::option::Option::Some(value::Val::UnixTimestampVal(v))
    }

    // .feast.types.BytesList bytes_list_val = 11;

    pub fn bytes_list_val(&self) -> &BytesList {
        match self.val {
            ::std::option::Option::Some(value::Val::BytesListVal(ref v)) => v,
            _ => <BytesList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bytes_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_bytes_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::BytesListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_list_val(&mut self, v: BytesList) {
        self.val = ::std::option::Option::Some(value::Val::BytesListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_list_val(&mut self) -> &mut BytesList {
        if let ::std::option::Option::Some(value::Val::BytesListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::BytesListVal(BytesList::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::BytesListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_list_val(&mut self) -> BytesList {
        if self.has_bytes_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::BytesListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            BytesList::new()
        }
    }

    // .feast.types.StringList string_list_val = 12;

    pub fn string_list_val(&self) -> &StringList {
        match self.val {
            ::std::option::Option::Some(value::Val::StringListVal(ref v)) => v,
            _ => <StringList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_string_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_string_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::StringListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_list_val(&mut self, v: StringList) {
        self.val = ::std::option::Option::Some(value::Val::StringListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_list_val(&mut self) -> &mut StringList {
        if let ::std::option::Option::Some(value::Val::StringListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::StringListVal(StringList::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::StringListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_list_val(&mut self) -> StringList {
        if self.has_string_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::StringListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            StringList::new()
        }
    }

    // .feast.types.Int32List int32_list_val = 13;

    pub fn int32_list_val(&self) -> &Int32List {
        match self.val {
            ::std::option::Option::Some(value::Val::Int32ListVal(ref v)) => v,
            _ => <Int32List as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_int32_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_int32_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::Int32ListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int32_list_val(&mut self, v: Int32List) {
        self.val = ::std::option::Option::Some(value::Val::Int32ListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int32_list_val(&mut self) -> &mut Int32List {
        if let ::std::option::Option::Some(value::Val::Int32ListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::Int32ListVal(Int32List::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::Int32ListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int32_list_val(&mut self) -> Int32List {
        if self.has_int32_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::Int32ListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            Int32List::new()
        }
    }

    // .feast.types.Int64List int64_list_val = 14;

    pub fn int64_list_val(&self) -> &Int64List {
        match self.val {
            ::std::option::Option::Some(value::Val::Int64ListVal(ref v)) => v,
            _ => <Int64List as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_int64_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_int64_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::Int64ListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64_list_val(&mut self, v: Int64List) {
        self.val = ::std::option::Option::Some(value::Val::Int64ListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int64_list_val(&mut self) -> &mut Int64List {
        if let ::std::option::Option::Some(value::Val::Int64ListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::Int64ListVal(Int64List::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::Int64ListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int64_list_val(&mut self) -> Int64List {
        if self.has_int64_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::Int64ListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            Int64List::new()
        }
    }

    // .feast.types.DoubleList double_list_val = 15;

    pub fn double_list_val(&self) -> &DoubleList {
        match self.val {
            ::std::option::Option::Some(value::Val::DoubleListVal(ref v)) => v,
            _ => <DoubleList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_double_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_double_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::DoubleListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_list_val(&mut self, v: DoubleList) {
        self.val = ::std::option::Option::Some(value::Val::DoubleListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_double_list_val(&mut self) -> &mut DoubleList {
        if let ::std::option::Option::Some(value::Val::DoubleListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::DoubleListVal(DoubleList::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::DoubleListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_double_list_val(&mut self) -> DoubleList {
        if self.has_double_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::DoubleListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            DoubleList::new()
        }
    }

    // .feast.types.FloatList float_list_val = 16;

    pub fn float_list_val(&self) -> &FloatList {
        match self.val {
            ::std::option::Option::Some(value::Val::FloatListVal(ref v)) => v,
            _ => <FloatList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_float_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_float_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::FloatListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_list_val(&mut self, v: FloatList) {
        self.val = ::std::option::Option::Some(value::Val::FloatListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float_list_val(&mut self) -> &mut FloatList {
        if let ::std::option::Option::Some(value::Val::FloatListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::FloatListVal(FloatList::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::FloatListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float_list_val(&mut self) -> FloatList {
        if self.has_float_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::FloatListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            FloatList::new()
        }
    }

    // .feast.types.BoolList bool_list_val = 17;

    pub fn bool_list_val(&self) -> &BoolList {
        match self.val {
            ::std::option::Option::Some(value::Val::BoolListVal(ref v)) => v,
            _ => <BoolList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bool_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_bool_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::BoolListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_list_val(&mut self, v: BoolList) {
        self.val = ::std::option::Option::Some(value::Val::BoolListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bool_list_val(&mut self) -> &mut BoolList {
        if let ::std::option::Option::Some(value::Val::BoolListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::BoolListVal(BoolList::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::BoolListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bool_list_val(&mut self) -> BoolList {
        if self.has_bool_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::BoolListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            BoolList::new()
        }
    }

    // .feast.types.Int64List unix_timestamp_list_val = 18;

    pub fn unix_timestamp_list_val(&self) -> &Int64List {
        match self.val {
            ::std::option::Option::Some(value::Val::UnixTimestampListVal(ref v)) => v,
            _ => <Int64List as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unix_timestamp_list_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_unix_timestamp_list_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::UnixTimestampListVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unix_timestamp_list_val(&mut self, v: Int64List) {
        self.val = ::std::option::Option::Some(value::Val::UnixTimestampListVal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unix_timestamp_list_val(&mut self) -> &mut Int64List {
        if let ::std::option::Option::Some(value::Val::UnixTimestampListVal(_)) = self.val {
        } else {
            self.val = ::std::option::Option::Some(value::Val::UnixTimestampListVal(Int64List::new()));
        }
        match self.val {
            ::std::option::Option::Some(value::Val::UnixTimestampListVal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unix_timestamp_list_val(&mut self) -> Int64List {
        if self.has_unix_timestamp_list_val() {
            match self.val.take() {
                ::std::option::Option::Some(value::Val::UnixTimestampListVal(v)) => v,
                _ => panic!(),
            }
        } else {
            Int64List::new()
        }
    }

    // .feast.types.Null null_val = 19;

    pub fn null_val(&self) -> Null {
        match self.val {
            ::std::option::Option::Some(value::Val::NullVal(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => Null::NULL,
        }
    }

    pub fn clear_null_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_null_val(&self) -> bool {
        match self.val {
            ::std::option::Option::Some(value::Val::NullVal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_null_val(&mut self, v: Null) {
        self.val = ::std::option::Option::Some(value::Val::NullVal(::protobuf::EnumOrUnknown::new(v)))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "bytes_val",
            Value::has_bytes_val,
            Value::bytes_val,
            Value::set_bytes_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string_val",
            Value::has_string_val,
            Value::string_val,
            Value::set_string_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int32_val",
            Value::has_int32_val,
            Value::int32_val,
            Value::set_int32_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int64_val",
            Value::has_int64_val,
            Value::int64_val,
            Value::set_int64_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "double_val",
            Value::has_double_val,
            Value::double_val,
            Value::set_double_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "float_val",
            Value::has_float_val,
            Value::float_val,
            Value::set_float_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool_val",
            Value::has_bool_val,
            Value::bool_val,
            Value::set_bool_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "unix_timestamp_val",
            Value::has_unix_timestamp_val,
            Value::unix_timestamp_val,
            Value::set_unix_timestamp_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BytesList>(
            "bytes_list_val",
            Value::has_bytes_list_val,
            Value::bytes_list_val,
            Value::mut_bytes_list_val,
            Value::set_bytes_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StringList>(
            "string_list_val",
            Value::has_string_list_val,
            Value::string_list_val,
            Value::mut_string_list_val,
            Value::set_string_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Int32List>(
            "int32_list_val",
            Value::has_int32_list_val,
            Value::int32_list_val,
            Value::mut_int32_list_val,
            Value::set_int32_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Int64List>(
            "int64_list_val",
            Value::has_int64_list_val,
            Value::int64_list_val,
            Value::mut_int64_list_val,
            Value::set_int64_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DoubleList>(
            "double_list_val",
            Value::has_double_list_val,
            Value::double_list_val,
            Value::mut_double_list_val,
            Value::set_double_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FloatList>(
            "float_list_val",
            Value::has_float_list_val,
            Value::float_list_val,
            Value::mut_float_list_val,
            Value::set_float_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BoolList>(
            "bool_list_val",
            Value::has_bool_list_val,
            Value::bool_list_val,
            Value::mut_bool_list_val,
            Value::set_bool_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Int64List>(
            "unix_timestamp_list_val",
            Value::has_unix_timestamp_list_val,
            Value::unix_timestamp_list_val,
            Value::mut_unix_timestamp_list_val,
            Value::set_unix_timestamp_list_val,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "null_val",
            |message: &Value| match &message.val {
                ::std::option::Option::Some(value::Val::NullVal(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut Value, e: ::protobuf::EnumOrUnknown<Null>| {
                message.val = ::std::option::Option::Some(value::Val::NullVal(e));
            },
            Null::NULL,
        ));
        oneofs.push(value::Val::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Value>(
            "Value",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Value {
    const NAME: &'static str = "Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val = ::std::option::Option::Some(value::Val::BytesVal(is.read_bytes()?));
                },
                18 => {
                    self.val = ::std::option::Option::Some(value::Val::StringVal(is.read_string()?));
                },
                24 => {
                    self.val = ::std::option::Option::Some(value::Val::Int32Val(is.read_int32()?));
                },
                32 => {
                    self.val = ::std::option::Option::Some(value::Val::Int64Val(is.read_int64()?));
                },
                41 => {
                    self.val = ::std::option::Option::Some(value::Val::DoubleVal(is.read_double()?));
                },
                53 => {
                    self.val = ::std::option::Option::Some(value::Val::FloatVal(is.read_float()?));
                },
                56 => {
                    self.val = ::std::option::Option::Some(value::Val::BoolVal(is.read_bool()?));
                },
                64 => {
                    self.val = ::std::option::Option::Some(value::Val::UnixTimestampVal(is.read_int64()?));
                },
                90 => {
                    self.val = ::std::option::Option::Some(value::Val::BytesListVal(is.read_message()?));
                },
                98 => {
                    self.val = ::std::option::Option::Some(value::Val::StringListVal(is.read_message()?));
                },
                106 => {
                    self.val = ::std::option::Option::Some(value::Val::Int32ListVal(is.read_message()?));
                },
                114 => {
                    self.val = ::std::option::Option::Some(value::Val::Int64ListVal(is.read_message()?));
                },
                122 => {
                    self.val = ::std::option::Option::Some(value::Val::DoubleListVal(is.read_message()?));
                },
                130 => {
                    self.val = ::std::option::Option::Some(value::Val::FloatListVal(is.read_message()?));
                },
                138 => {
                    self.val = ::std::option::Option::Some(value::Val::BoolListVal(is.read_message()?));
                },
                146 => {
                    self.val = ::std::option::Option::Some(value::Val::UnixTimestampListVal(is.read_message()?));
                },
                152 => {
                    self.val = ::std::option::Option::Some(value::Val::NullVal(is.read_enum_or_unknown()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.val {
            match v {
                &value::Val::BytesVal(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &value::Val::StringVal(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &value::Val::Int32Val(v) => {
                    my_size += ::protobuf::rt::int32_size(3, v);
                },
                &value::Val::Int64Val(v) => {
                    my_size += ::protobuf::rt::int64_size(4, v);
                },
                &value::Val::DoubleVal(v) => {
                    my_size += 1 + 8;
                },
                &value::Val::FloatVal(v) => {
                    my_size += 1 + 4;
                },
                &value::Val::BoolVal(v) => {
                    my_size += 1 + 1;
                },
                &value::Val::UnixTimestampVal(v) => {
                    my_size += ::protobuf::rt::int64_size(8, v);
                },
                &value::Val::BytesListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::StringListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::Int32ListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::Int64ListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::DoubleListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::FloatListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::BoolListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::UnixTimestampListVal(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Val::NullVal(v) => {
                    my_size += ::protobuf::rt::int32_size(19, v.value());
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.val {
            match v {
                &value::Val::BytesVal(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &value::Val::StringVal(ref v) => {
                    os.write_string(2, v)?;
                },
                &value::Val::Int32Val(v) => {
                    os.write_int32(3, v)?;
                },
                &value::Val::Int64Val(v) => {
                    os.write_int64(4, v)?;
                },
                &value::Val::DoubleVal(v) => {
                    os.write_double(5, v)?;
                },
                &value::Val::FloatVal(v) => {
                    os.write_float(6, v)?;
                },
                &value::Val::BoolVal(v) => {
                    os.write_bool(7, v)?;
                },
                &value::Val::UnixTimestampVal(v) => {
                    os.write_int64(8, v)?;
                },
                &value::Val::BytesListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &value::Val::StringListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &value::Val::Int32ListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &value::Val::Int64ListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &value::Val::DoubleListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &value::Val::FloatListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &value::Val::BoolListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &value::Val::UnixTimestampListVal(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &value::Val::NullVal(v) => {
                    os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Value {
        Value::new()
    }

    fn clear(&mut self) {
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Value {
        static instance: Value = Value {
            val: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Value {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Value`
pub mod value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.types.Value.val)
    pub enum Val {
        // @@protoc_insertion_point(oneof_field:feast.types.Value.bytes_val)
        BytesVal(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.string_val)
        StringVal(::std::string::String),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.int32_val)
        Int32Val(i32),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.int64_val)
        Int64Val(i64),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.double_val)
        DoubleVal(f64),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.float_val)
        FloatVal(f32),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.bool_val)
        BoolVal(bool),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.unix_timestamp_val)
        UnixTimestampVal(i64),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.bytes_list_val)
        BytesListVal(super::BytesList),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.string_list_val)
        StringListVal(super::StringList),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.int32_list_val)
        Int32ListVal(super::Int32List),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.int64_list_val)
        Int64ListVal(super::Int64List),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.double_list_val)
        DoubleListVal(super::DoubleList),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.float_list_val)
        FloatListVal(super::FloatList),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.bool_list_val)
        BoolListVal(super::BoolList),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.unix_timestamp_list_val)
        UnixTimestampListVal(super::Int64List),
        // @@protoc_insertion_point(oneof_field:feast.types.Value.null_val)
        NullVal(::protobuf::EnumOrUnknown<super::Null>),
    }

    impl ::protobuf::Oneof for Val {
    }

    impl ::protobuf::OneofFull for Val {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Value as ::protobuf::MessageFull>::descriptor().oneof_by_name("val").unwrap()).clone()
        }
    }

    impl Val {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Val>("val")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.BytesList)
pub struct BytesList {
    // message fields
    // @@protoc_insertion_point(field:feast.types.BytesList.val)
    pub val: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.BytesList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BytesList {
    fn default() -> &'a BytesList {
        <BytesList as ::protobuf::Message>::default_instance()
    }
}

impl BytesList {
    pub fn new() -> BytesList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &BytesList| { &m.val },
            |m: &mut BytesList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BytesList>(
            "BytesList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BytesList {
    const NAME: &'static str = "BytesList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BytesList {
        BytesList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BytesList {
        static instance: BytesList = BytesList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BytesList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BytesList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BytesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BytesList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.StringList)
pub struct StringList {
    // message fields
    // @@protoc_insertion_point(field:feast.types.StringList.val)
    pub val: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.StringList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringList {
    fn default() -> &'a StringList {
        <StringList as ::protobuf::Message>::default_instance()
    }
}

impl StringList {
    pub fn new() -> StringList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &StringList| { &m.val },
            |m: &mut StringList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringList>(
            "StringList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringList {
    const NAME: &'static str = "StringList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringList {
        StringList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringList {
        static instance: StringList = StringList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.Int32List)
pub struct Int32List {
    // message fields
    // @@protoc_insertion_point(field:feast.types.Int32List.val)
    pub val: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.Int32List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Int32List {
    fn default() -> &'a Int32List {
        <Int32List as ::protobuf::Message>::default_instance()
    }
}

impl Int32List {
    pub fn new() -> Int32List {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Int32List| { &m.val },
            |m: &mut Int32List| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Int32List>(
            "Int32List",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Int32List {
    const NAME: &'static str = "Int32List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.val)?;
                },
                8 => {
                    self.val.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Int32List {
        Int32List::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Int32List {
        static instance: Int32List = Int32List {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Int32List {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Int32List").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Int32List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Int32List {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.Int64List)
pub struct Int64List {
    // message fields
    // @@protoc_insertion_point(field:feast.types.Int64List.val)
    pub val: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.Int64List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Int64List {
    fn default() -> &'a Int64List {
        <Int64List as ::protobuf::Message>::default_instance()
    }
}

impl Int64List {
    pub fn new() -> Int64List {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Int64List| { &m.val },
            |m: &mut Int64List| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Int64List>(
            "Int64List",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Int64List {
    const NAME: &'static str = "Int64List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.val)?;
                },
                8 => {
                    self.val.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Int64List {
        Int64List::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Int64List {
        static instance: Int64List = Int64List {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Int64List {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Int64List").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Int64List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Int64List {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.DoubleList)
pub struct DoubleList {
    // message fields
    // @@protoc_insertion_point(field:feast.types.DoubleList.val)
    pub val: ::std::vec::Vec<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.DoubleList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoubleList {
    fn default() -> &'a DoubleList {
        <DoubleList as ::protobuf::Message>::default_instance()
    }
}

impl DoubleList {
    pub fn new() -> DoubleList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &DoubleList| { &m.val },
            |m: &mut DoubleList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoubleList>(
            "DoubleList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoubleList {
    const NAME: &'static str = "DoubleList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_double_into(&mut self.val)?;
                },
                9 => {
                    self.val.push(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.val.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_double(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoubleList {
        DoubleList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoubleList {
        static instance: DoubleList = DoubleList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoubleList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoubleList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoubleList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoubleList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.FloatList)
pub struct FloatList {
    // message fields
    // @@protoc_insertion_point(field:feast.types.FloatList.val)
    pub val: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.FloatList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatList {
    fn default() -> &'a FloatList {
        <FloatList as ::protobuf::Message>::default_instance()
    }
}

impl FloatList {
    pub fn new() -> FloatList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &FloatList| { &m.val },
            |m: &mut FloatList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FloatList>(
            "FloatList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FloatList {
    const NAME: &'static str = "FloatList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.val)?;
                },
                13 => {
                    self.val.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.val.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatList {
        FloatList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatList {
        static instance: FloatList = FloatList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FloatList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FloatList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FloatList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.BoolList)
pub struct BoolList {
    // message fields
    // @@protoc_insertion_point(field:feast.types.BoolList.val)
    pub val: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.BoolList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoolList {
    fn default() -> &'a BoolList {
        <BoolList as ::protobuf::Message>::default_instance()
    }
}

impl BoolList {
    pub fn new() -> BoolList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &BoolList| { &m.val },
            |m: &mut BoolList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BoolList>(
            "BoolList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BoolList {
    const NAME: &'static str = "BoolList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_bool_into(&mut self.val)?;
                },
                8 => {
                    self.val.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 2 * self.val.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoolList {
        BoolList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoolList {
        static instance: BoolList = BoolList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BoolList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BoolList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BoolList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoolList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is to avoid an issue of being unable to specify `repeated value` in oneofs or maps
///  In JSON "val" field can be omitted
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.types.RepeatedValue)
pub struct RepeatedValue {
    // message fields
    // @@protoc_insertion_point(field:feast.types.RepeatedValue.val)
    pub val: ::std::vec::Vec<Value>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.types.RepeatedValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RepeatedValue {
    fn default() -> &'a RepeatedValue {
        <RepeatedValue as ::protobuf::Message>::default_instance()
    }
}

impl RepeatedValue {
    pub fn new() -> RepeatedValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &RepeatedValue| { &m.val },
            |m: &mut RepeatedValue| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RepeatedValue>(
            "RepeatedValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RepeatedValue {
    const NAME: &'static str = "RepeatedValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RepeatedValue {
        RepeatedValue::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RepeatedValue {
        static instance: RepeatedValue = RepeatedValue {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RepeatedValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RepeatedValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RepeatedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RepeatedValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:feast.types.Null)
pub enum Null {
    // @@protoc_insertion_point(enum_value:feast.types.Null.NULL)
    NULL = 0,
}

impl ::protobuf::Enum for Null {
    const NAME: &'static str = "Null";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Null> {
        match value {
            0 => ::std::option::Option::Some(Null::NULL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Null] = &[
        Null::NULL,
    ];
}

impl ::protobuf::EnumFull for Null {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Null").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Null {
    fn default() -> Self {
        Null::NULL
    }
}

impl Null {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Null>("Null")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17feast/types/Value.proto\x12\x0bfeast.types\"\x97\x02\n\tValueType\
    \"\x89\x02\n\x04Enum\x12\x0b\n\x07INVALID\x10\0\x12\t\n\x05BYTES\x10\x01\
    \x12\n\n\x06STRING\x10\x02\x12\t\n\x05INT32\x10\x03\x12\t\n\x05INT64\x10\
    \x04\x12\n\n\x06DOUBLE\x10\x05\x12\t\n\x05FLOAT\x10\x06\x12\x08\n\x04BOO\
    L\x10\x07\x12\x12\n\x0eUNIX_TIMESTAMP\x10\x08\x12\x0e\n\nBYTES_LIST\x10\
    \x0b\x12\x0f\n\x0bSTRING_LIST\x10\x0c\x12\x0e\n\nINT32_LIST\x10\r\x12\
    \x0e\n\nINT64_LIST\x10\x0e\x12\x0f\n\x0bDOUBLE_LIST\x10\x0f\x12\x0e\n\nF\
    LOAT_LIST\x10\x10\x12\r\n\tBOOL_LIST\x10\x11\x12\x17\n\x13UNIX_TIMESTAMP\
    _LIST\x10\x12\x12\x08\n\x04NULL\x10\x13\"\xdd\x06\n\x05Value\x12\x1d\n\t\
    bytes_val\x18\x01\x20\x01(\x0cH\0R\x08bytesVal\x12\x1f\n\nstring_val\x18\
    \x02\x20\x01(\tH\0R\tstringVal\x12\x1d\n\tint32_val\x18\x03\x20\x01(\x05\
    H\0R\x08int32Val\x12\x1d\n\tint64_val\x18\x04\x20\x01(\x03H\0R\x08int64V\
    al\x12\x1f\n\ndouble_val\x18\x05\x20\x01(\x01H\0R\tdoubleVal\x12\x1d\n\t\
    float_val\x18\x06\x20\x01(\x02H\0R\x08floatVal\x12\x1b\n\x08bool_val\x18\
    \x07\x20\x01(\x08H\0R\x07boolVal\x12.\n\x12unix_timestamp_val\x18\x08\
    \x20\x01(\x03H\0R\x10unixTimestampVal\x12>\n\x0ebytes_list_val\x18\x0b\
    \x20\x01(\x0b2\x16.feast.types.BytesListH\0R\x0cbytesListVal\x12A\n\x0fs\
    tring_list_val\x18\x0c\x20\x01(\x0b2\x17.feast.types.StringListH\0R\rstr\
    ingListVal\x12>\n\x0eint32_list_val\x18\r\x20\x01(\x0b2\x16.feast.types.\
    Int32ListH\0R\x0cint32ListVal\x12>\n\x0eint64_list_val\x18\x0e\x20\x01(\
    \x0b2\x16.feast.types.Int64ListH\0R\x0cint64ListVal\x12A\n\x0fdouble_lis\
    t_val\x18\x0f\x20\x01(\x0b2\x17.feast.types.DoubleListH\0R\rdoubleListVa\
    l\x12>\n\x0efloat_list_val\x18\x10\x20\x01(\x0b2\x16.feast.types.FloatLi\
    stH\0R\x0cfloatListVal\x12;\n\rbool_list_val\x18\x11\x20\x01(\x0b2\x15.f\
    east.types.BoolListH\0R\x0bboolListVal\x12O\n\x17unix_timestamp_list_val\
    \x18\x12\x20\x01(\x0b2\x16.feast.types.Int64ListH\0R\x14unixTimestampLis\
    tVal\x12.\n\x08null_val\x18\x13\x20\x01(\x0e2\x11.feast.types.NullH\0R\
    \x07nullValB\x05\n\x03val\"\x1d\n\tBytesList\x12\x10\n\x03val\x18\x01\
    \x20\x03(\x0cR\x03val\"\x1e\n\nStringList\x12\x10\n\x03val\x18\x01\x20\
    \x03(\tR\x03val\"\x1d\n\tInt32List\x12\x10\n\x03val\x18\x01\x20\x03(\x05\
    R\x03val\"\x1d\n\tInt64List\x12\x10\n\x03val\x18\x01\x20\x03(\x03R\x03va\
    l\"\x1e\n\nDoubleList\x12\x10\n\x03val\x18\x01\x20\x03(\x01R\x03val\"\
    \x1d\n\tFloatList\x12\x10\n\x03val\x18\x01\x20\x03(\x02R\x03val\"\x1c\n\
    \x08BoolList\x12\x10\n\x03val\x18\x01\x20\x03(\x08R\x03val\"5\n\rRepeate\
    dValue\x12$\n\x03val\x18\x01\x20\x03(\x0b2\x12.feast.types.ValueR\x03val\
    *\x10\n\x04Null\x12\x08\n\x04NULL\x10\0BQ\n\x11feast.proto.typesB\nValue\
    ProtoZ0github.com/feast-dev/feast/go/protos/feast/typesJ\xe5\x1c\n\x06\
    \x12\x04\x10\0l\x01\n\xc5\x04\n\x01\x0c\x12\x03\x10\0\x122\xba\x04\n\x20\
    Copyright\x202018\x20The\x20Feast\x20Authors\n\n\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compli\
    ance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\
    \x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20https://www.apache\
    .org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\
    \x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distrib\
    uted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\
    \x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\
    \x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x12\0\x14\n\x08\n\x01\x08\x12\x03\x14\0*\n\t\n\x02\x08\x01\
    \x12\x03\x14\0*\n\x08\n\x01\x08\x12\x03\x15\0+\n\t\n\x02\x08\x08\x12\x03\
    \x15\0+\n\x08\n\x01\x08\x12\x03\x16\0G\n\t\n\x02\x08\x0b\x12\x03\x16\0G\
    \n\n\n\x02\x04\0\x12\x04\x18\0-\x01\n\n\n\x03\x04\0\x01\x12\x03\x18\x08\
    \x11\n\x0c\n\x04\x04\0\x04\0\x12\x04\x19\x02,\x03\n\x0c\n\x05\x04\0\x04\
    \0\x01\x12\x03\x19\x07\x0b\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x1a\x04\
    \x10\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03\x1a\x04\x0b\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x02\x12\x03\x1a\x0e\x0f\n\r\n\x06\x04\0\x04\0\x02\x01\
    \x12\x03\x1b\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\x1b\x04\
    \t\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03\x1b\x0c\r\n\r\n\x06\x04\0\
    \x04\0\x02\x02\x12\x03\x1c\x04\x0f\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\
    \x12\x03\x1c\x04\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\x1c\r\x0e\
    \n\r\n\x06\x04\0\x04\0\x02\x03\x12\x03\x1d\x04\x0e\n\x0e\n\x07\x04\0\x04\
    \0\x02\x03\x01\x12\x03\x1d\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\
    \x03\x1d\x0c\r\n\r\n\x06\x04\0\x04\0\x02\x04\x12\x03\x1e\x04\x0e\n\x0e\n\
    \x07\x04\0\x04\0\x02\x04\x01\x12\x03\x1e\x04\t\n\x0e\n\x07\x04\0\x04\0\
    \x02\x04\x02\x12\x03\x1e\x0c\r\n\r\n\x06\x04\0\x04\0\x02\x05\x12\x03\x1f\
    \x04\x0f\n\x0e\n\x07\x04\0\x04\0\x02\x05\x01\x12\x03\x1f\x04\n\n\x0e\n\
    \x07\x04\0\x04\0\x02\x05\x02\x12\x03\x1f\r\x0e\n\r\n\x06\x04\0\x04\0\x02\
    \x06\x12\x03\x20\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x06\x01\x12\x03\x20\
    \x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x06\x02\x12\x03\x20\x0c\r\n\r\n\x06\
    \x04\0\x04\0\x02\x07\x12\x03!\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x07\x01\
    \x12\x03!\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x07\x02\x12\x03!\x0b\x0c\n\
    \r\n\x06\x04\0\x04\0\x02\x08\x12\x03\"\x04\x17\n\x0e\n\x07\x04\0\x04\0\
    \x02\x08\x01\x12\x03\"\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\x08\x02\x12\
    \x03\"\x15\x16\n\r\n\x06\x04\0\x04\0\x02\t\x12\x03#\x04\x14\n\x0e\n\x07\
    \x04\0\x04\0\x02\t\x01\x12\x03#\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\t\
    \x02\x12\x03#\x11\x13\n\r\n\x06\x04\0\x04\0\x02\n\x12\x03$\x04\x15\n\x0e\
    \n\x07\x04\0\x04\0\x02\n\x01\x12\x03$\x04\x0f\n\x0e\n\x07\x04\0\x04\0\
    \x02\n\x02\x12\x03$\x12\x14\n\r\n\x06\x04\0\x04\0\x02\x0b\x12\x03%\x04\
    \x14\n\x0e\n\x07\x04\0\x04\0\x02\x0b\x01\x12\x03%\x04\x0e\n\x0e\n\x07\
    \x04\0\x04\0\x02\x0b\x02\x12\x03%\x11\x13\n\r\n\x06\x04\0\x04\0\x02\x0c\
    \x12\x03&\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\x0c\x01\x12\x03&\x04\x0e\n\
    \x0e\n\x07\x04\0\x04\0\x02\x0c\x02\x12\x03&\x11\x13\n\r\n\x06\x04\0\x04\
    \0\x02\r\x12\x03'\x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\r\x01\x12\x03'\x04\
    \x0f\n\x0e\n\x07\x04\0\x04\0\x02\r\x02\x12\x03'\x12\x14\n\r\n\x06\x04\0\
    \x04\0\x02\x0e\x12\x03(\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\x0e\x01\x12\
    \x03(\x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x0e\x02\x12\x03(\x11\x13\n\r\n\
    \x06\x04\0\x04\0\x02\x0f\x12\x03)\x04\x13\n\x0e\n\x07\x04\0\x04\0\x02\
    \x0f\x01\x12\x03)\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x0f\x02\x12\x03)\x10\
    \x12\n\r\n\x06\x04\0\x04\0\x02\x10\x12\x03*\x04\x1d\n\x0e\n\x07\x04\0\
    \x04\0\x02\x10\x01\x12\x03*\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x10\x02\
    \x12\x03*\x1a\x1c\n\r\n\x06\x04\0\x04\0\x02\x11\x12\x03+\x04\x0e\n\x0e\n\
    \x07\x04\0\x04\0\x02\x11\x01\x12\x03+\x04\x08\n\x0e\n\x07\x04\0\x04\0\
    \x02\x11\x02\x12\x03+\x0b\r\n\n\n\x02\x04\x01\x12\x04/\0F\x01\n\n\n\x03\
    \x04\x01\x01\x12\x03/\x08\r\n\xd1\x01\n\x04\x04\x01\x08\0\x12\x043\x02E\
    \x03\x1a\xc2\x01\x20ValueType\x20is\x20referenced\x20by\x20the\x20metada\
    ta\x20types,\x20FeatureInfo\x20and\x20EntityInfo.\n\x20The\x20enum\x20va\
    lues\x20do\x20not\x20have\x20to\x20match\x20the\x20oneof\x20val\x20field\
    \x20ids,\x20but\x20they\x20should.\n\x20In\x20JSON\x20\"*_val\"\x20field\
    \x20can\x20be\x20omitted\n\n\x0c\n\x05\x04\x01\x08\0\x01\x12\x033\x08\
    \x0b\n\x0b\n\x04\x04\x01\x02\0\x12\x034\x04\x18\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x034\x04\t\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x034\n\x13\n\x0c\
    \n\x05\x04\x01\x02\0\x03\x12\x034\x16\x17\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x035\x04\x1a\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x035\x04\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x035\x0b\x15\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x035\x18\x19\n\x0b\n\x04\x04\x01\x02\x02\x12\x036\x04\x18\n\x0c\
    \n\x05\x04\x01\x02\x02\x05\x12\x036\x04\t\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x036\n\x13\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x036\x16\x17\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x037\x04\x18\n\x0c\n\x05\x04\x01\x02\x03\
    \x05\x12\x037\x04\t\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x037\n\x13\n\x0c\
    \n\x05\x04\x01\x02\x03\x03\x12\x037\x16\x17\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x038\x04\x1a\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x038\x04\n\n\x0c\n\
    \x05\x04\x01\x02\x04\x01\x12\x038\x0b\x15\n\x0c\n\x05\x04\x01\x02\x04\
    \x03\x12\x038\x18\x19\n\x0b\n\x04\x04\x01\x02\x05\x12\x039\x04\x18\n\x0c\
    \n\x05\x04\x01\x02\x05\x05\x12\x039\x04\t\n\x0c\n\x05\x04\x01\x02\x05\
    \x01\x12\x039\n\x13\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x039\x16\x17\n\
    \x0b\n\x04\x04\x01\x02\x06\x12\x03:\x04\x16\n\x0c\n\x05\x04\x01\x02\x06\
    \x05\x12\x03:\x04\x08\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03:\t\x11\n\
    \x0c\n\x05\x04\x01\x02\x06\x03\x12\x03:\x14\x15\n\x0b\n\x04\x04\x01\x02\
    \x07\x12\x03;\x04!\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03;\x04\t\n\x0c\
    \n\x05\x04\x01\x02\x07\x01\x12\x03;\n\x1c\n\x0c\n\x05\x04\x01\x02\x07\
    \x03\x12\x03;\x1f\x20\n\x0b\n\x04\x04\x01\x02\x08\x12\x03<\x04\"\n\x0c\n\
    \x05\x04\x01\x02\x08\x06\x12\x03<\x04\r\n\x0c\n\x05\x04\x01\x02\x08\x01\
    \x12\x03<\x0e\x1c\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03<\x1f!\n\x0b\n\
    \x04\x04\x01\x02\t\x12\x03=\x04$\n\x0c\n\x05\x04\x01\x02\t\x06\x12\x03=\
    \x04\x0e\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03=\x0f\x1e\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03=!#\n\x0b\n\x04\x04\x01\x02\n\x12\x03>\x04\"\n\x0c\
    \n\x05\x04\x01\x02\n\x06\x12\x03>\x04\r\n\x0c\n\x05\x04\x01\x02\n\x01\
    \x12\x03>\x0e\x1c\n\x0c\n\x05\x04\x01\x02\n\x03\x12\x03>\x1f!\n\x0b\n\
    \x04\x04\x01\x02\x0b\x12\x03?\x04\"\n\x0c\n\x05\x04\x01\x02\x0b\x06\x12\
    \x03?\x04\r\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03?\x0e\x1c\n\x0c\n\x05\
    \x04\x01\x02\x0b\x03\x12\x03?\x1f!\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03@\
    \x04$\n\x0c\n\x05\x04\x01\x02\x0c\x06\x12\x03@\x04\x0e\n\x0c\n\x05\x04\
    \x01\x02\x0c\x01\x12\x03@\x0f\x1e\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\
    \x03@!#\n\x0b\n\x04\x04\x01\x02\r\x12\x03A\x04\"\n\x0c\n\x05\x04\x01\x02\
    \r\x06\x12\x03A\x04\r\n\x0c\n\x05\x04\x01\x02\r\x01\x12\x03A\x0e\x1c\n\
    \x0c\n\x05\x04\x01\x02\r\x03\x12\x03A\x1f!\n\x0b\n\x04\x04\x01\x02\x0e\
    \x12\x03B\x04\x20\n\x0c\n\x05\x04\x01\x02\x0e\x06\x12\x03B\x04\x0c\n\x0c\
    \n\x05\x04\x01\x02\x0e\x01\x12\x03B\r\x1a\n\x0c\n\x05\x04\x01\x02\x0e\
    \x03\x12\x03B\x1d\x1f\n\x0b\n\x04\x04\x01\x02\x0f\x12\x03C\x04+\n\x0c\n\
    \x05\x04\x01\x02\x0f\x06\x12\x03C\x04\r\n\x0c\n\x05\x04\x01\x02\x0f\x01\
    \x12\x03C\x0e%\n\x0c\n\x05\x04\x01\x02\x0f\x03\x12\x03C(*\n\x0b\n\x04\
    \x04\x01\x02\x10\x12\x03D\x04\x17\n\x0c\n\x05\x04\x01\x02\x10\x06\x12\
    \x03D\x04\x08\n\x0c\n\x05\x04\x01\x02\x10\x01\x12\x03D\t\x11\n\x0c\n\x05\
    \x04\x01\x02\x10\x03\x12\x03D\x14\x16\n\n\n\x02\x05\0\x12\x04H\0J\x01\n\
    \n\n\x03\x05\0\x01\x12\x03H\x05\t\n\x0b\n\x04\x05\0\x02\0\x12\x03I\x02\
    \x0b\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03I\x02\x06\n\x0c\n\x05\x05\0\x02\
    \0\x02\x12\x03I\t\n\n\n\n\x02\x04\x02\x12\x04L\0N\x01\n\n\n\x03\x04\x02\
    \x01\x12\x03L\x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\x03M\x02\x19\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x03M\x0b\x10\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03M\x11\x14\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03M\x17\x18\n\n\n\x02\x04\x03\x12\x04P\0R\x01\n\
    \n\n\x03\x04\x03\x01\x12\x03P\x08\x12\n\x0b\n\x04\x04\x03\x02\0\x12\x03Q\
    \x02\x1a\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\
    \x03\x02\0\x05\x12\x03Q\x0b\x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03Q\
    \x12\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03Q\x18\x19\n\n\n\x02\x04\
    \x04\x12\x04T\0V\x01\n\n\n\x03\x04\x04\x01\x12\x03T\x08\x11\n\x0b\n\x04\
    \x04\x04\x02\0\x12\x03U\x02\x19\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03U\
    \x02\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03U\x0b\x10\n\x0c\n\x05\x04\
    \x04\x02\0\x01\x12\x03U\x11\x14\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03U\
    \x17\x18\n\n\n\x02\x04\x05\x12\x04X\0Z\x01\n\n\n\x03\x04\x05\x01\x12\x03\
    X\x08\x11\n\x0b\n\x04\x04\x05\x02\0\x12\x03Y\x02\x19\n\x0c\n\x05\x04\x05\
    \x02\0\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Y\x0b\x10\
    \n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03Y\x11\x14\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x03Y\x17\x18\n\n\n\x02\x04\x06\x12\x04\\\0^\x01\n\n\n\x03\x04\
    \x06\x01\x12\x03\\\x08\x12\n\x0b\n\x04\x04\x06\x02\0\x12\x03]\x02\x1a\n\
    \x0c\n\x05\x04\x06\x02\0\x04\x12\x03]\x02\n\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03]\x0b\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03]\x12\x15\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03]\x18\x19\n\n\n\x02\x04\x07\x12\x04`\
    \0b\x01\n\n\n\x03\x04\x07\x01\x12\x03`\x08\x11\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03a\x02\x19\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03a\x02\n\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03a\x0b\x10\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x03a\x11\x14\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03a\x17\x18\n\n\n\
    \x02\x04\x08\x12\x04d\0f\x01\n\n\n\x03\x04\x08\x01\x12\x03d\x08\x10\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03e\x02\x18\n\x0c\n\x05\x04\x08\x02\0\x04\
    \x12\x03e\x02\n\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03e\x0b\x0f\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x03e\x10\x13\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03e\x16\x17\n\x89\x01\n\x02\x04\t\x12\x04j\0l\x01\x1a}\x20This\x20\
    is\x20to\x20avoid\x20an\x20issue\x20of\x20being\x20unable\x20to\x20speci\
    fy\x20`repeated\x20value`\x20in\x20oneofs\x20or\x20maps\n\x20In\x20JSON\
    \x20\"val\"\x20field\x20can\x20be\x20omitted\n\n\n\n\x03\x04\t\x01\x12\
    \x03j\x08\x15\n\x0b\n\x04\x04\t\x02\0\x12\x03k\x02\x19\n\x0c\n\x05\x04\t\
    \x02\0\x04\x12\x03k\x02\n\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03k\x0b\x10\n\
    \x0c\n\x05\x04\t\x02\0\x01\x12\x03k\x11\x14\n\x0c\n\x05\x04\t\x02\0\x03\
    \x12\x03k\x17\x18b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(ValueType::generated_message_descriptor_data());
            messages.push(Value::generated_message_descriptor_data());
            messages.push(BytesList::generated_message_descriptor_data());
            messages.push(StringList::generated_message_descriptor_data());
            messages.push(Int32List::generated_message_descriptor_data());
            messages.push(Int64List::generated_message_descriptor_data());
            messages.push(DoubleList::generated_message_descriptor_data());
            messages.push(FloatList::generated_message_descriptor_data());
            messages.push(BoolList::generated_message_descriptor_data());
            messages.push(RepeatedValue::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(Null::generated_enum_descriptor_data());
            enums.push(value_type::Enum::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
