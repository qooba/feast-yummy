// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/serving/ServingService.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetFeastServingInfoRequest)
pub struct GetFeastServingInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetFeastServingInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFeastServingInfoRequest {
    fn default() -> &'a GetFeastServingInfoRequest {
        <GetFeastServingInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFeastServingInfoRequest {
    pub fn new() -> GetFeastServingInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFeastServingInfoRequest>(
            "GetFeastServingInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFeastServingInfoRequest {
    const NAME: &'static str = "GetFeastServingInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFeastServingInfoRequest {
        GetFeastServingInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFeastServingInfoRequest {
        static instance: GetFeastServingInfoRequest = GetFeastServingInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFeastServingInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFeastServingInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFeastServingInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeastServingInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetFeastServingInfoResponse)
pub struct GetFeastServingInfoResponse {
    // message fields
    ///  Feast version of this serving deployment.
    // @@protoc_insertion_point(field:feast.serving.GetFeastServingInfoResponse.version)
    pub version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetFeastServingInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFeastServingInfoResponse {
    fn default() -> &'a GetFeastServingInfoResponse {
        <GetFeastServingInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFeastServingInfoResponse {
    pub fn new() -> GetFeastServingInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &GetFeastServingInfoResponse| { &m.version },
            |m: &mut GetFeastServingInfoResponse| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFeastServingInfoResponse>(
            "GetFeastServingInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFeastServingInfoResponse {
    const NAME: &'static str = "GetFeastServingInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFeastServingInfoResponse {
        GetFeastServingInfoResponse::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFeastServingInfoResponse {
        static instance: GetFeastServingInfoResponse = GetFeastServingInfoResponse {
            version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFeastServingInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFeastServingInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFeastServingInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeastServingInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.FeatureReferenceV2)
pub struct FeatureReferenceV2 {
    // message fields
    ///  Name of the Feature View to retrieve the feature from.
    // @@protoc_insertion_point(field:feast.serving.FeatureReferenceV2.feature_view_name)
    pub feature_view_name: ::std::string::String,
    ///  Name of the Feature to retrieve the feature from.
    // @@protoc_insertion_point(field:feast.serving.FeatureReferenceV2.feature_name)
    pub feature_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.FeatureReferenceV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureReferenceV2 {
    fn default() -> &'a FeatureReferenceV2 {
        <FeatureReferenceV2 as ::protobuf::Message>::default_instance()
    }
}

impl FeatureReferenceV2 {
    pub fn new() -> FeatureReferenceV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_view_name",
            |m: &FeatureReferenceV2| { &m.feature_view_name },
            |m: &mut FeatureReferenceV2| { &mut m.feature_view_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_name",
            |m: &FeatureReferenceV2| { &m.feature_name },
            |m: &mut FeatureReferenceV2| { &mut m.feature_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureReferenceV2>(
            "FeatureReferenceV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureReferenceV2 {
    const NAME: &'static str = "FeatureReferenceV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.feature_view_name = is.read_string()?;
                },
                18 => {
                    self.feature_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.feature_view_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feature_view_name);
        }
        if !self.feature_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feature_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.feature_view_name.is_empty() {
            os.write_string(1, &self.feature_view_name)?;
        }
        if !self.feature_name.is_empty() {
            os.write_string(2, &self.feature_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureReferenceV2 {
        FeatureReferenceV2::new()
    }

    fn clear(&mut self) {
        self.feature_view_name.clear();
        self.feature_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureReferenceV2 {
        static instance: FeatureReferenceV2 = FeatureReferenceV2 {
            feature_view_name: ::std::string::String::new(),
            feature_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureReferenceV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureReferenceV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureReferenceV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureReferenceV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ToDo (oleksii): remove this message (since it's not used) and move EntityRow on package level
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesRequestV2)
pub struct GetOnlineFeaturesRequestV2 {
    // message fields
    ///  List of features that are being retrieved
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequestV2.features)
    pub features: ::std::vec::Vec<FeatureReferenceV2>,
    ///  List of entity rows, containing entity id and timestamp data.
    ///  Used during retrieval of feature rows and for joining feature
    ///  rows into a final dataset
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequestV2.entity_rows)
    pub entity_rows: ::std::vec::Vec<get_online_features_request_v2::EntityRow>,
    ///  Optional field to specify project name override. If specified, uses the
    ///  given project for retrieval. Overrides the projects specified in
    ///  Feature References if both are specified.
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequestV2.project)
    pub project: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesRequestV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOnlineFeaturesRequestV2 {
    fn default() -> &'a GetOnlineFeaturesRequestV2 {
        <GetOnlineFeaturesRequestV2 as ::protobuf::Message>::default_instance()
    }
}

impl GetOnlineFeaturesRequestV2 {
    pub fn new() -> GetOnlineFeaturesRequestV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &GetOnlineFeaturesRequestV2| { &m.features },
            |m: &mut GetOnlineFeaturesRequestV2| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity_rows",
            |m: &GetOnlineFeaturesRequestV2| { &m.entity_rows },
            |m: &mut GetOnlineFeaturesRequestV2| { &mut m.entity_rows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &GetOnlineFeaturesRequestV2| { &m.project },
            |m: &mut GetOnlineFeaturesRequestV2| { &mut m.project },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOnlineFeaturesRequestV2>(
            "GetOnlineFeaturesRequestV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOnlineFeaturesRequestV2 {
    const NAME: &'static str = "GetOnlineFeaturesRequestV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.features.push(is.read_message()?);
                },
                18 => {
                    self.entity_rows.push(is.read_message()?);
                },
                42 => {
                    self.project = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.entity_rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.project);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.entity_rows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.project.is_empty() {
            os.write_string(5, &self.project)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOnlineFeaturesRequestV2 {
        GetOnlineFeaturesRequestV2::new()
    }

    fn clear(&mut self) {
        self.features.clear();
        self.entity_rows.clear();
        self.project.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOnlineFeaturesRequestV2 {
        static instance: GetOnlineFeaturesRequestV2 = GetOnlineFeaturesRequestV2 {
            features: ::std::vec::Vec::new(),
            entity_rows: ::std::vec::Vec::new(),
            project: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOnlineFeaturesRequestV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOnlineFeaturesRequestV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOnlineFeaturesRequestV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOnlineFeaturesRequestV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetOnlineFeaturesRequestV2`
pub mod get_online_features_request_v2 {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesRequestV2.EntityRow)
    pub struct EntityRow {
        // message fields
        ///  Request timestamp of this row. This value will be used,
        ///  together with maxAge, to determine feature staleness.
        // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequestV2.EntityRow.timestamp)
        pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
        ///  Map containing mapping of entity name to entity value.
        // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequestV2.EntityRow.fields)
        pub fields: ::std::collections::HashMap<::std::string::String, super::super::Value::Value>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesRequestV2.EntityRow.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EntityRow {
        fn default() -> &'a EntityRow {
            <EntityRow as ::protobuf::Message>::default_instance()
        }
    }

    impl EntityRow {
        pub fn new() -> EntityRow {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                "timestamp",
                |m: &EntityRow| { &m.timestamp },
                |m: &mut EntityRow| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "fields",
                |m: &EntityRow| { &m.fields },
                |m: &mut EntityRow| { &mut m.fields },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntityRow>(
                "GetOnlineFeaturesRequestV2.EntityRow",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EntityRow {
        const NAME: &'static str = "EntityRow";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_message()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.fields.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for (k, v) in &self.fields {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.compute_size();
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.timestamp.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for (k, v) in &self.fields {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                let len = v.cached_size() as u64;
                entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EntityRow {
            EntityRow::new()
        }

        fn clear(&mut self) {
            self.timestamp.clear();
            self.fields.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EntityRow {
            static instance: ::protobuf::rt::Lazy<EntityRow> = ::protobuf::rt::Lazy::new();
            instance.get(EntityRow::new)
        }
    }

    impl ::protobuf::MessageFull for EntityRow {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetOnlineFeaturesRequestV2.EntityRow").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EntityRow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EntityRow {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  In JSON "val" field can be omitted
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.FeatureList)
pub struct FeatureList {
    // message fields
    // @@protoc_insertion_point(field:feast.serving.FeatureList.val)
    pub val: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.FeatureList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureList {
    fn default() -> &'a FeatureList {
        <FeatureList as ::protobuf::Message>::default_instance()
    }
}

impl FeatureList {
    pub fn new() -> FeatureList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &FeatureList| { &m.val },
            |m: &mut FeatureList| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureList>(
            "FeatureList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureList {
    const NAME: &'static str = "FeatureList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureList {
        FeatureList::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureList {
        static instance: FeatureList = FeatureList {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesRequest)
pub struct GetOnlineFeaturesRequest {
    // message fields
    ///  The entity data is specified in a columnar format
    ///  A map of entity name -> list of values
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequest.entities)
    pub entities: ::std::collections::HashMap<::std::string::String, super::Value::RepeatedValue>,
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequest.full_feature_names)
    pub full_feature_names: bool,
    ///  Context for OnDemand Feature Transformation
    ///  (was moved to dedicated parameter to avoid unnecessary separation logic on serving side)
    ///  A map of variable name -> list of values
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesRequest.request_context)
    pub request_context: ::std::collections::HashMap<::std::string::String, super::Value::RepeatedValue>,
    // message oneof groups
    pub kind: ::std::option::Option<get_online_features_request::Kind>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOnlineFeaturesRequest {
    fn default() -> &'a GetOnlineFeaturesRequest {
        <GetOnlineFeaturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOnlineFeaturesRequest {
    pub fn new() -> GetOnlineFeaturesRequest {
        ::std::default::Default::default()
    }

    // string feature_service = 1;

    pub fn feature_service(&self) -> &str {
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_feature_service(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_feature_service(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_feature_service(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(v))
    }

    // Mutable pointer to the field.
    pub fn mut_feature_service(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(::std::string::String::new()));
        }
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_feature_service(&mut self) -> ::std::string::String {
        if self.has_feature_service() {
            match self.kind.take() {
                ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .feast.serving.FeatureList features = 2;

    pub fn features(&self) -> &FeatureList {
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::Features(ref v)) => v,
            _ => <FeatureList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_features(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_features(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::Features(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: FeatureList) {
        self.kind = ::std::option::Option::Some(get_online_features_request::Kind::Features(v))
    }

    // Mutable pointer to the field.
    pub fn mut_features(&mut self) -> &mut FeatureList {
        if let ::std::option::Option::Some(get_online_features_request::Kind::Features(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(get_online_features_request::Kind::Features(FeatureList::new()));
        }
        match self.kind {
            ::std::option::Option::Some(get_online_features_request::Kind::Features(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_features(&mut self) -> FeatureList {
        if self.has_features() {
            match self.kind.take() {
                ::std::option::Option::Some(get_online_features_request::Kind::Features(v)) => v,
                _ => panic!(),
            }
        } else {
            FeatureList::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "feature_service",
            GetOnlineFeaturesRequest::has_feature_service,
            GetOnlineFeaturesRequest::feature_service,
            GetOnlineFeaturesRequest::set_feature_service,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FeatureList>(
            "features",
            GetOnlineFeaturesRequest::has_features,
            GetOnlineFeaturesRequest::features,
            GetOnlineFeaturesRequest::mut_features,
            GetOnlineFeaturesRequest::set_features,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "entities",
            |m: &GetOnlineFeaturesRequest| { &m.entities },
            |m: &mut GetOnlineFeaturesRequest| { &mut m.entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "full_feature_names",
            |m: &GetOnlineFeaturesRequest| { &m.full_feature_names },
            |m: &mut GetOnlineFeaturesRequest| { &mut m.full_feature_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "request_context",
            |m: &GetOnlineFeaturesRequest| { &m.request_context },
            |m: &mut GetOnlineFeaturesRequest| { &mut m.request_context },
        ));
        oneofs.push(get_online_features_request::Kind::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOnlineFeaturesRequest>(
            "GetOnlineFeaturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOnlineFeaturesRequest {
    const NAME: &'static str = "GetOnlineFeaturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kind = ::std::option::Option::Some(get_online_features_request::Kind::FeatureService(is.read_string()?));
                },
                18 => {
                    self.kind = ::std::option::Option::Some(get_online_features_request::Kind::Features(is.read_message()?));
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.entities.insert(key, value);
                },
                32 => {
                    self.full_feature_names = is.read_bool()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.request_context.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.entities {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.full_feature_names != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.request_context {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &get_online_features_request::Kind::FeatureService(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &get_online_features_request::Kind::Features(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.entities {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.full_feature_names != false {
            os.write_bool(4, self.full_feature_names)?;
        }
        for (k, v) in &self.request_context {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &get_online_features_request::Kind::FeatureService(ref v) => {
                    os.write_string(1, v)?;
                },
                &get_online_features_request::Kind::Features(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOnlineFeaturesRequest {
        GetOnlineFeaturesRequest::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.entities.clear();
        self.full_feature_names = false;
        self.request_context.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOnlineFeaturesRequest {
        static instance: ::protobuf::rt::Lazy<GetOnlineFeaturesRequest> = ::protobuf::rt::Lazy::new();
        instance.get(GetOnlineFeaturesRequest::new)
    }
}

impl ::protobuf::MessageFull for GetOnlineFeaturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOnlineFeaturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOnlineFeaturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOnlineFeaturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetOnlineFeaturesRequest`
pub mod get_online_features_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.serving.GetOnlineFeaturesRequest.kind)
    pub enum Kind {
        // @@protoc_insertion_point(oneof_field:feast.serving.GetOnlineFeaturesRequest.feature_service)
        FeatureService(::std::string::String),
        // @@protoc_insertion_point(oneof_field:feast.serving.GetOnlineFeaturesRequest.features)
        Features(super::FeatureList),
    }

    impl ::protobuf::Oneof for Kind {
    }

    impl ::protobuf::OneofFull for Kind {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::GetOnlineFeaturesRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("kind").unwrap()).clone()
        }
    }

    impl Kind {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Kind>("kind")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesResponse)
pub struct GetOnlineFeaturesResponse {
    // message fields
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponse.metadata)
    pub metadata: ::protobuf::MessageField<GetOnlineFeaturesResponseMetadata>,
    ///  Length of "results" array should match length of requested features.
    ///  We also preserve the same order of features here as in metadata.feature_names
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponse.results)
    pub results: ::std::vec::Vec<get_online_features_response::FeatureVector>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOnlineFeaturesResponse {
    fn default() -> &'a GetOnlineFeaturesResponse {
        <GetOnlineFeaturesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetOnlineFeaturesResponse {
    pub fn new() -> GetOnlineFeaturesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetOnlineFeaturesResponseMetadata>(
            "metadata",
            |m: &GetOnlineFeaturesResponse| { &m.metadata },
            |m: &mut GetOnlineFeaturesResponse| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &GetOnlineFeaturesResponse| { &m.results },
            |m: &mut GetOnlineFeaturesResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOnlineFeaturesResponse>(
            "GetOnlineFeaturesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOnlineFeaturesResponse {
    const NAME: &'static str = "GetOnlineFeaturesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOnlineFeaturesResponse {
        GetOnlineFeaturesResponse::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOnlineFeaturesResponse {
        static instance: GetOnlineFeaturesResponse = GetOnlineFeaturesResponse {
            metadata: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOnlineFeaturesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOnlineFeaturesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOnlineFeaturesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOnlineFeaturesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetOnlineFeaturesResponse`
pub mod get_online_features_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesResponse.FeatureVector)
    pub struct FeatureVector {
        // message fields
        // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponse.FeatureVector.values)
        pub values: ::std::vec::Vec<super::super::Value::Value>,
        // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponse.FeatureVector.statuses)
        pub statuses: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::FieldStatus>>,
        // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponse.FeatureVector.event_timestamps)
        pub event_timestamps: ::std::vec::Vec<::protobuf::well_known_types::timestamp::Timestamp>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesResponse.FeatureVector.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FeatureVector {
        fn default() -> &'a FeatureVector {
            <FeatureVector as ::protobuf::Message>::default_instance()
        }
    }

    impl FeatureVector {
        pub fn new() -> FeatureVector {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "values",
                |m: &FeatureVector| { &m.values },
                |m: &mut FeatureVector| { &mut m.values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "statuses",
                |m: &FeatureVector| { &m.statuses },
                |m: &mut FeatureVector| { &mut m.statuses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "event_timestamps",
                |m: &FeatureVector| { &m.event_timestamps },
                |m: &mut FeatureVector| { &mut m.event_timestamps },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureVector>(
                "GetOnlineFeaturesResponse.FeatureVector",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FeatureVector {
        const NAME: &'static str = "FeatureVector";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.values.push(is.read_message()?);
                    },
                    16 => {
                        self.statuses.push(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.statuses)?
                    },
                    26 => {
                        self.event_timestamps.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.statuses {
                my_size += ::protobuf::rt::int32_size(2, value.value());
            };
            for value in &self.event_timestamps {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.values {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.statuses {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
            };
            for v in &self.event_timestamps {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FeatureVector {
            FeatureVector::new()
        }

        fn clear(&mut self) {
            self.values.clear();
            self.statuses.clear();
            self.event_timestamps.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FeatureVector {
            static instance: FeatureVector = FeatureVector {
                values: ::std::vec::Vec::new(),
                statuses: ::std::vec::Vec::new(),
                event_timestamps: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FeatureVector {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetOnlineFeaturesResponse.FeatureVector").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FeatureVector {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FeatureVector {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.serving.GetOnlineFeaturesResponseMetadata)
pub struct GetOnlineFeaturesResponseMetadata {
    // message fields
    // @@protoc_insertion_point(field:feast.serving.GetOnlineFeaturesResponseMetadata.feature_names)
    pub feature_names: ::protobuf::MessageField<FeatureList>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.serving.GetOnlineFeaturesResponseMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOnlineFeaturesResponseMetadata {
    fn default() -> &'a GetOnlineFeaturesResponseMetadata {
        <GetOnlineFeaturesResponseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl GetOnlineFeaturesResponseMetadata {
    pub fn new() -> GetOnlineFeaturesResponseMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureList>(
            "feature_names",
            |m: &GetOnlineFeaturesResponseMetadata| { &m.feature_names },
            |m: &mut GetOnlineFeaturesResponseMetadata| { &mut m.feature_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOnlineFeaturesResponseMetadata>(
            "GetOnlineFeaturesResponseMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOnlineFeaturesResponseMetadata {
    const NAME: &'static str = "GetOnlineFeaturesResponseMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feature_names)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feature_names.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.feature_names.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOnlineFeaturesResponseMetadata {
        GetOnlineFeaturesResponseMetadata::new()
    }

    fn clear(&mut self) {
        self.feature_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOnlineFeaturesResponseMetadata {
        static instance: GetOnlineFeaturesResponseMetadata = GetOnlineFeaturesResponseMetadata {
            feature_names: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOnlineFeaturesResponseMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOnlineFeaturesResponseMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOnlineFeaturesResponseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOnlineFeaturesResponseMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:feast.serving.FieldStatus)
pub enum FieldStatus {
    // @@protoc_insertion_point(enum_value:feast.serving.FieldStatus.INVALID)
    INVALID = 0,
    // @@protoc_insertion_point(enum_value:feast.serving.FieldStatus.PRESENT)
    PRESENT = 1,
    // @@protoc_insertion_point(enum_value:feast.serving.FieldStatus.NULL_VALUE)
    NULL_VALUE = 2,
    // @@protoc_insertion_point(enum_value:feast.serving.FieldStatus.NOT_FOUND)
    NOT_FOUND = 3,
    // @@protoc_insertion_point(enum_value:feast.serving.FieldStatus.OUTSIDE_MAX_AGE)
    OUTSIDE_MAX_AGE = 4,
}

impl ::protobuf::Enum for FieldStatus {
    const NAME: &'static str = "FieldStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FieldStatus> {
        match value {
            0 => ::std::option::Option::Some(FieldStatus::INVALID),
            1 => ::std::option::Option::Some(FieldStatus::PRESENT),
            2 => ::std::option::Option::Some(FieldStatus::NULL_VALUE),
            3 => ::std::option::Option::Some(FieldStatus::NOT_FOUND),
            4 => ::std::option::Option::Some(FieldStatus::OUTSIDE_MAX_AGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FieldStatus] = &[
        FieldStatus::INVALID,
        FieldStatus::PRESENT,
        FieldStatus::NULL_VALUE,
        FieldStatus::NOT_FOUND,
        FieldStatus::OUTSIDE_MAX_AGE,
    ];
}

impl ::protobuf::EnumFull for FieldStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FieldStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FieldStatus {
    fn default() -> Self {
        FieldStatus::INVALID
    }
}

impl FieldStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FieldStatus>("FieldStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"feast/serving/ServingService.proto\x12\rfeast.serving\x1a\x1fgoogle/\
    protobuf/timestamp.proto\x1a\x17feast/types/Value.proto\"\x1c\n\x1aGetFe\
    astServingInfoRequest\"7\n\x1bGetFeastServingInfoResponse\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\tR\x07version\"c\n\x12FeatureReferenceV2\x12*\n\
    \x11feature_view_name\x18\x01\x20\x01(\tR\x0ffeatureViewName\x12!\n\x0cf\
    eature_name\x18\x02\x20\x01(\tR\x0bfeatureName\"\xbb\x03\n\x1aGetOnlineF\
    eaturesRequestV2\x12=\n\x08features\x18\x04\x20\x03(\x0b2!.feast.serving\
    .FeatureReferenceV2R\x08features\x12T\n\x0bentity_rows\x18\x02\x20\x03(\
    \x0b23.feast.serving.GetOnlineFeaturesRequestV2.EntityRowR\nentityRows\
    \x12\x18\n\x07project\x18\x05\x20\x01(\tR\x07project\x1a\xed\x01\n\tEnti\
    tyRow\x128\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\ttimestamp\x12W\n\x06fields\x18\x02\x20\x03(\x0b2?.feast.serving.Ge\
    tOnlineFeaturesRequestV2.EntityRow.FieldsEntryR\x06fields\x1aM\n\x0bFiel\
    dsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12(\n\x05value\x18\
    \x02\x20\x01(\x0b2\x12.feast.types.ValueR\x05value:\x028\x01\"\x1f\n\x0b\
    FeatureList\x12\x10\n\x03val\x18\x01\x20\x03(\tR\x03val\"\xa6\x04\n\x18G\
    etOnlineFeaturesRequest\x12)\n\x0ffeature_service\x18\x01\x20\x01(\tH\0R\
    \x0efeatureService\x128\n\x08features\x18\x02\x20\x01(\x0b2\x1a.feast.se\
    rving.FeatureListH\0R\x08features\x12Q\n\x08entities\x18\x03\x20\x03(\
    \x0b25.feast.serving.GetOnlineFeaturesRequest.EntitiesEntryR\x08entities\
    \x12,\n\x12full_feature_names\x18\x04\x20\x01(\x08R\x10fullFeatureNames\
    \x12d\n\x0frequest_context\x18\x05\x20\x03(\x0b2;.feast.serving.GetOnlin\
    eFeaturesRequest.RequestContextEntryR\x0erequestContext\x1aW\n\rEntities\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x120\n\x05value\x18\
    \x02\x20\x01(\x0b2\x1a.feast.types.RepeatedValueR\x05value:\x028\x01\x1a\
    ]\n\x13RequestContextEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x120\n\x05value\x18\x02\x20\x01(\x0b2\x1a.feast.types.RepeatedValueR\
    \x05value:\x028\x01B\x06\n\x04kind\"\xf8\x02\n\x19GetOnlineFeaturesRespo\
    nse\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.feast.serving.GetOnlineFea\
    turesResponseMetadataR\x08metadata\x12P\n\x07results\x18\x02\x20\x03(\
    \x0b26.feast.serving.GetOnlineFeaturesResponse.FeatureVectorR\x07results\
    \x1a\xba\x01\n\rFeatureVector\x12*\n\x06values\x18\x01\x20\x03(\x0b2\x12\
    .feast.types.ValueR\x06values\x126\n\x08statuses\x18\x02\x20\x03(\x0e2\
    \x1a.feast.serving.FieldStatusR\x08statuses\x12E\n\x10event_timestamps\
    \x18\x03\x20\x03(\x0b2\x1a.google.protobuf.TimestampR\x0feventTimestamps\
    \"d\n!GetOnlineFeaturesResponseMetadata\x12?\n\rfeature_names\x18\x01\
    \x20\x01(\x0b2\x1a.feast.serving.FeatureListR\x0cfeatureNames*[\n\x0bFie\
    ldStatus\x12\x0b\n\x07INVALID\x10\0\x12\x0b\n\x07PRESENT\x10\x01\x12\x0e\
    \n\nNULL_VALUE\x10\x02\x12\r\n\tNOT_FOUND\x10\x03\x12\x13\n\x0fOUTSIDE_M\
    AX_AGE\x10\x042\xe6\x01\n\x0eServingService\x12l\n\x13GetFeastServingInf\
    o\x12).feast.serving.GetFeastServingInfoRequest\x1a*.feast.serving.GetFe\
    astServingInfoResponse\x12f\n\x11GetOnlineFeatures\x12'.feast.serving.Ge\
    tOnlineFeaturesRequest\x1a(.feast.serving.GetOnlineFeaturesResponseBZ\n\
    \x13feast.proto.servingB\x0fServingAPIProtoZ2github.com/feast-dev/feast/\
    go/protos/feast/servingJ\xe7\"\n\x07\x12\x05\x10\0\x84\x01\x01\n\xc5\x04\
    \n\x01\x0c\x12\x03\x10\0\x122\xba\x04\n\x20Copyright\x202018\x20The\x20F\
    east\x20Authors\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\
    \x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20us\
    e\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20Licens\
    e.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\
    \n\n\x20\x20\x20\x20\x20https://www.apache.org/licenses/LICENSE-2.0\n\n\
    \x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\
    \x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\x20Licen\
    se\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHO\
    UT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20\
    express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20sp\
    ecific\x20language\x20governing\x20permissions\x20and\n\x20limitations\
    \x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x12\0\x16\n\t\n\
    \x02\x03\0\x12\x03\x14\0)\n\t\n\x02\x03\x01\x12\x03\x15\0!\n\x08\n\x01\
    \x08\x12\x03\x17\0,\n\t\n\x02\x08\x01\x12\x03\x17\0,\n\x08\n\x01\x08\x12\
    \x03\x18\00\n\t\n\x02\x08\x08\x12\x03\x18\00\n\x08\n\x01\x08\x12\x03\x19\
    \0I\n\t\n\x02\x08\x0b\x12\x03\x19\0I\n\n\n\x02\x06\0\x12\x04\x1b\0\x20\
    \x01\n\n\n\x03\x06\0\x01\x12\x03\x1b\x08\x16\n8\n\x04\x06\0\x02\0\x12\
    \x03\x1d\x04_\x1a+\x20Get\x20information\x20about\x20this\x20Feast\x20se\
    rving.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x1d\x08\x1b\n\x0c\n\x05\x06\
    \0\x02\0\x02\x12\x03\x1d\x1d7\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x1dB]\
    \n1\n\x04\x06\0\x02\x01\x12\x03\x1f\x04Y\x1a$\x20Get\x20online\x20featur\
    es\x20synchronously.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x1f\x08\x19\
    \n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x1f\x1b3\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\x1f>W\n\t\n\x02\x04\0\x12\x03\"\0%\n\n\n\x03\x04\0\x01\
    \x12\x03\"\x08\"\n\n\n\x02\x04\x01\x12\x04$\0'\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03$\x08#\n8\n\x04\x04\x01\x02\0\x12\x03&\x04\x17\x1a+\x20Feast\x20\
    version\x20of\x20this\x20serving\x20deployment.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03&\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03&\x0b\x12\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03&\x15\x16\n\n\n\x02\x04\x02\x12\
    \x04)\0/\x01\n\n\n\x03\x04\x02\x01\x12\x03)\x08\x1a\nE\n\x04\x04\x02\x02\
    \0\x12\x03+\x04!\x1a8\x20Name\x20of\x20the\x20Feature\x20View\x20to\x20r\
    etrieve\x20the\x20feature\x20from.\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x03+\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03+\x0b\x1c\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03+\x1f\x20\n@\n\x04\x04\x02\x02\x01\x12\x03.\
    \x04\x1c\x1a3\x20Name\x20of\x20the\x20Feature\x20to\x20retrieve\x20the\
    \x20feature\x20from.\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03.\x04\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03.\x0b\x17\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03.\x1a\x1b\nk\n\x02\x04\x03\x12\x042\0H\x01\x1a_\x20ToDo\
    \x20(oleksii):\x20remove\x20this\x20message\x20(since\x20it's\x20not\x20\
    used)\x20and\x20move\x20EntityRow\x20on\x20package\x20level\n\n\n\n\x03\
    \x04\x03\x01\x12\x032\x08\"\n8\n\x04\x04\x03\x02\0\x12\x034\x04-\x1a+\
    \x20List\x20of\x20features\x20that\x20are\x20being\x20retrieved\n\n\x0c\
    \n\x05\x04\x03\x02\0\x04\x12\x034\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x06\
    \x12\x034\r\x1f\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x034\x20(\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x034+,\n\xa7\x01\n\x04\x04\x03\x02\x01\x12\x039\
    \x04'\x1a\x99\x01\x20List\x20of\x20entity\x20rows,\x20containing\x20enti\
    ty\x20id\x20and\x20timestamp\x20data.\n\x20Used\x20during\x20retrieval\
    \x20of\x20feature\x20rows\x20and\x20for\x20joining\x20feature\n\x20rows\
    \x20into\x20a\x20final\x20dataset\n\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\
    \x039\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x039\r\x16\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x039\x17\"\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x039%&\n\xc4\x01\n\x04\x04\x03\x02\x02\x12\x03>\x04\x17\x1a\xb6\x01\x20\
    Optional\x20field\x20to\x20specify\x20project\x20name\x20override.\x20If\
    \x20specified,\x20uses\x20the\n\x20given\x20project\x20for\x20retrieval.\
    \x20Overrides\x20the\x20projects\x20specified\x20in\n\x20Feature\x20Refe\
    rences\x20if\x20both\x20are\x20specified.\n\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03>\x04\n\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03>\x0b\x12\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03>\x15\x16\n\x0c\n\x04\x04\x03\x03\
    \0\x12\x04@\x04G\x05\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03@\x0c\x15\n\
    \x7f\n\x06\x04\x03\x03\0\x02\0\x12\x03C\x080\x1ap\x20Request\x20timestam\
    p\x20of\x20this\x20row.\x20This\x20value\x20will\x20be\x20used,\n\x20tog\
    ether\x20with\x20maxAge,\x20to\x20determine\x20feature\x20staleness.\n\n\
    \x0e\n\x07\x04\x03\x03\0\x02\0\x06\x12\x03C\x08!\n\x0e\n\x07\x04\x03\x03\
    \0\x02\0\x01\x12\x03C\"+\n\x0e\n\x07\x04\x03\x03\0\x02\0\x03\x12\x03C./\
    \nG\n\x06\x04\x03\x03\0\x02\x01\x12\x03F\x081\x1a8\x20Map\x20containing\
    \x20mapping\x20of\x20entity\x20name\x20to\x20entity\x20value.\n\n\x0e\n\
    \x07\x04\x03\x03\0\x02\x01\x06\x12\x03F\x08%\n\x0e\n\x07\x04\x03\x03\0\
    \x02\x01\x01\x12\x03F&,\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x03F/0\
    \n0\n\x02\x04\x04\x12\x04K\0M\x01\x1a$\x20In\x20JSON\x20\"val\"\x20field\
    \x20can\x20be\x20omitted\n\n\n\n\x03\x04\x04\x01\x12\x03K\x08\x13\n\x0b\
    \n\x04\x04\x04\x02\0\x12\x03L\x04\x1c\n\x0c\n\x05\x04\x04\x02\0\x04\x12\
    \x03L\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03L\r\x13\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03L\x14\x17\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03L\x1a\x1b\n\n\n\x02\x04\x05\x12\x04O\0]\x01\n\n\n\x03\x04\x05\x01\
    \x12\x03O\x08\x20\n\x0c\n\x04\x04\x05\x08\0\x12\x04P\x04S\x05\n\x0c\n\
    \x05\x04\x05\x08\0\x01\x12\x03P\n\x0e\n\x0b\n\x04\x04\x05\x02\0\x12\x03Q\
    \x08#\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Q\x08\x0e\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03Q\x0f\x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03Q!\"\n\
    \x0b\n\x04\x04\x05\x02\x01\x12\x03R\x08!\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x03R\x08\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03R\x14\x1c\n\x0c\
    \n\x05\x04\x05\x02\x01\x03\x12\x03R\x1f\x20\nh\n\x04\x04\x05\x02\x02\x12\
    \x03V\x048\x1a[\x20The\x20entity\x20data\x20is\x20specified\x20in\x20a\
    \x20columnar\x20format\n\x20A\x20map\x20of\x20entity\x20name\x20->\x20li\
    st\x20of\x20values\n\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03V\x04*\n\x0c\
    \n\x05\x04\x05\x02\x02\x01\x12\x03V+3\n\x0c\n\x05\x04\x05\x02\x02\x03\
    \x12\x03V67\n\x0b\n\x04\x04\x05\x02\x03\x12\x03W\x04\x20\n\x0c\n\x05\x04\
    \x05\x02\x03\x05\x12\x03W\x04\x08\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\
    \x03W\t\x1b\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03W\x1e\x1f\n\xbf\x01\n\
    \x04\x04\x05\x02\x04\x12\x03\\\x04?\x1a\xb1\x01\x20Context\x20for\x20OnD\
    emand\x20Feature\x20Transformation\n\x20(was\x20moved\x20to\x20dedicated\
    \x20parameter\x20to\x20avoid\x20unnecessary\x20separation\x20logic\x20on\
    \x20serving\x20side)\n\x20A\x20map\x20of\x20variable\x20name\x20->\x20li\
    st\x20of\x20values\n\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03\\\x04*\n\
    \x0c\n\x05\x04\x05\x02\x04\x01\x12\x03\\+:\n\x0c\n\x05\x04\x05\x02\x04\
    \x03\x12\x03\\=>\n\n\n\x02\x04\x06\x12\x04_\0k\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03_\x08!\n\x0b\n\x04\x04\x06\x02\0\x12\x03`\x043\n\x0c\n\x05\x04\
    \x06\x02\0\x06\x12\x03`\x04%\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03`&.\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03`12\n\xa3\x01\n\x04\x04\x06\x02\x01\
    \x12\x03d\x04'\x1a\x95\x01\x20Length\x20of\x20\"results\"\x20array\x20sh\
    ould\x20match\x20length\x20of\x20requested\x20features.\n\x20We\x20also\
    \x20preserve\x20the\x20same\x20order\x20of\x20features\x20here\x20as\x20\
    in\x20metadata.feature_names\n\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03d\
    \x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03d\r\x1a\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03d\x1b\"\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03d\
    %&\n\x0c\n\x04\x04\x06\x03\0\x12\x04f\x04j\x05\n\x0c\n\x05\x04\x06\x03\0\
    \x01\x12\x03f\x0c\x19\n\r\n\x06\x04\x06\x03\0\x02\0\x12\x03g\x08.\n\x0e\
    \n\x07\x04\x06\x03\0\x02\0\x04\x12\x03g\x08\x10\n\x0e\n\x07\x04\x06\x03\
    \0\x02\0\x06\x12\x03g\x11\"\n\x0e\n\x07\x04\x06\x03\0\x02\0\x01\x12\x03g\
    #)\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03g,-\n\r\n\x06\x04\x06\x03\
    \0\x02\x01\x12\x03h\x08*\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x03h\
    \x08\x10\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x06\x12\x03h\x11\x1c\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x01\x01\x12\x03h\x1d%\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x01\x03\x12\x03h()\n\r\n\x06\x04\x06\x03\0\x02\x02\x12\x03i\x08@\n\
    \x0e\n\x07\x04\x06\x03\0\x02\x02\x04\x12\x03i\x08\x10\n\x0e\n\x07\x04\
    \x06\x03\0\x02\x02\x06\x12\x03i\x11*\n\x0e\n\x07\x04\x06\x03\0\x02\x02\
    \x01\x12\x03i+;\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x03i>?\n\n\n\
    \x02\x04\x07\x12\x04m\0o\x01\n\n\n\x03\x04\x07\x01\x12\x03m\x08)\n\x0b\n\
    \x04\x04\x07\x02\0\x12\x03n\x04\"\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03n\
    \x04\x0f\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03n\x10\x1d\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03n\x20!\n\x0b\n\x02\x05\0\x12\x05q\0\x84\x01\x01\n\
    \n\n\x03\x05\0\x01\x12\x03q\x05\x10\n.\n\x04\x05\0\x02\0\x12\x03s\x04\
    \x10\x1a!\x20Status\x20is\x20unset\x20for\x20this\x20field.\n\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03s\x04\x0b\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03s\x0e\x0f\nO\n\x04\x05\0\x02\x01\x12\x03v\x04\x10\x1aB\x20Field\x20v\
    alue\x20is\x20present\x20for\x20this\x20field\x20and\x20age\x20is\x20wit\
    hin\x20max\x20age.\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03v\x04\x0b\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03v\x0e\x0f\n\x92\x01\n\x04\x05\0\x02\
    \x02\x12\x03z\x04\x13\x1a\x84\x01\x20Values\x20could\x20be\x20found\x20f\
    or\x20entity\x20key\x20and\x20age\x20is\x20within\x20max\x20age,\x20but\
    \n\x20this\x20field\x20value\x20is\x20assigned\x20a\x20value\x20on\x20in\
    gestion\x20into\x20feast.\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03z\x04\
    \x0e\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03z\x11\x12\n\xbf\x01\n\x04\x05\
    \0\x02\x03\x12\x03\x7f\x04\x12\x1a\xb1\x01\x20Entity\x20key\x20did\x20no\
    t\x20return\x20any\x20values\x20as\x20they\x20do\x20not\x20exist\x20in\
    \x20Feast.\n\x20This\x20could\x20suggest\x20that\x20the\x20feature\x20va\
    lues\x20have\x20not\x20yet\x20been\x20ingested\n\x20into\x20feast\x20or\
    \x20the\x20ingestion\x20failed.\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\
    \x7f\x04\r\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x7f\x10\x11\np\n\x04\
    \x05\0\x02\x04\x12\x04\x83\x01\x04\x18\x1ab\x20Values\x20could\x20be\x20\
    found\x20for\x20entity\x20key,\x20but\x20field\x20values\x20are\x20outsi\
    de\x20the\x20maximum\n\x20allowable\x20range.\n\n\r\n\x05\x05\0\x02\x04\
    \x01\x12\x04\x83\x01\x04\x13\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\x83\x01\
    \x16\x17b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(super::Value::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(GetFeastServingInfoRequest::generated_message_descriptor_data());
            messages.push(GetFeastServingInfoResponse::generated_message_descriptor_data());
            messages.push(FeatureReferenceV2::generated_message_descriptor_data());
            messages.push(GetOnlineFeaturesRequestV2::generated_message_descriptor_data());
            messages.push(FeatureList::generated_message_descriptor_data());
            messages.push(GetOnlineFeaturesRequest::generated_message_descriptor_data());
            messages.push(GetOnlineFeaturesResponse::generated_message_descriptor_data());
            messages.push(GetOnlineFeaturesResponseMetadata::generated_message_descriptor_data());
            messages.push(get_online_features_request_v2::EntityRow::generated_message_descriptor_data());
            messages.push(get_online_features_response::FeatureVector::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(FieldStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
