// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `feast/core/DataSource.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  Defines a Data Source that can be used source Feature data
///  Next available id: 28
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:feast.core.DataSource)
pub struct DataSource {
    // message fields
    ///  Unique name of data source within the project
    // @@protoc_insertion_point(field:feast.core.DataSource.name)
    pub name: ::std::string::String,
    ///  Name of Feast project that this data source belongs to.
    // @@protoc_insertion_point(field:feast.core.DataSource.project)
    pub project: ::std::string::String,
    // @@protoc_insertion_point(field:feast.core.DataSource.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:feast.core.DataSource.tags)
    pub tags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:feast.core.DataSource.owner)
    pub owner: ::std::string::String,
    // @@protoc_insertion_point(field:feast.core.DataSource.type)
    pub type_: ::protobuf::EnumOrUnknown<data_source::SourceType>,
    ///  Defines mapping between fields in the sourced data
    ///  and fields in parent FeatureTable.
    // @@protoc_insertion_point(field:feast.core.DataSource.field_mapping)
    pub field_mapping: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  Must specify event timestamp column name
    // @@protoc_insertion_point(field:feast.core.DataSource.timestamp_field)
    pub timestamp_field: ::std::string::String,
    ///  (Optional) Specify partition column
    ///  useful for file sources
    // @@protoc_insertion_point(field:feast.core.DataSource.date_partition_column)
    pub date_partition_column: ::std::string::String,
    ///  Must specify creation timestamp column name
    // @@protoc_insertion_point(field:feast.core.DataSource.created_timestamp_column)
    pub created_timestamp_column: ::std::string::String,
    ///  This is an internal field that is represents the python class for the data source object a proto object represents.
    ///  This should be set by feast, and not by users.
    ///  The field is used primarily by custom data sources and is mandatory for them to set. Feast may set it for
    ///  first party sources as well.
    // @@protoc_insertion_point(field:feast.core.DataSource.data_source_class_type)
    pub data_source_class_type: ::std::string::String,
    ///  Optional batch source for streaming sources for historical features and materialization.
    // @@protoc_insertion_point(field:feast.core.DataSource.batch_source)
    pub batch_source: ::protobuf::MessageField<DataSource>,
    // message oneof groups
    pub options: ::std::option::Option<data_source::Options>,
    // special fields
    // @@protoc_insertion_point(special_field:feast.core.DataSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataSource {
    fn default() -> &'a DataSource {
        <DataSource as ::protobuf::Message>::default_instance()
    }
}

impl DataSource {
    pub fn new() -> DataSource {
        ::std::default::Default::default()
    }

    // .feast.core.DataSource.FileOptions file_options = 11;

    pub fn file_options(&self) -> &data_source::FileOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::FileOptions(ref v)) => v,
            _ => <data_source::FileOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_file_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::FileOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_options(&mut self, v: data_source::FileOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::FileOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_options(&mut self) -> &mut data_source::FileOptions {
        if let ::std::option::Option::Some(data_source::Options::FileOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::FileOptions(data_source::FileOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::FileOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_options(&mut self) -> data_source::FileOptions {
        if self.has_file_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::FileOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::FileOptions::new()
        }
    }

    // .feast.core.DataSource.BigQueryOptions bigquery_options = 12;

    pub fn bigquery_options(&self) -> &data_source::BigQueryOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::BigqueryOptions(ref v)) => v,
            _ => <data_source::BigQueryOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bigquery_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_bigquery_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::BigqueryOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_options(&mut self, v: data_source::BigQueryOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::BigqueryOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_options(&mut self) -> &mut data_source::BigQueryOptions {
        if let ::std::option::Option::Some(data_source::Options::BigqueryOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::BigqueryOptions(data_source::BigQueryOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::BigqueryOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_options(&mut self) -> data_source::BigQueryOptions {
        if self.has_bigquery_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::BigqueryOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::BigQueryOptions::new()
        }
    }

    // .feast.core.DataSource.KafkaOptions kafka_options = 13;

    pub fn kafka_options(&self) -> &data_source::KafkaOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::KafkaOptions(ref v)) => v,
            _ => <data_source::KafkaOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kafka_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_kafka_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::KafkaOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kafka_options(&mut self, v: data_source::KafkaOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::KafkaOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kafka_options(&mut self) -> &mut data_source::KafkaOptions {
        if let ::std::option::Option::Some(data_source::Options::KafkaOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::KafkaOptions(data_source::KafkaOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::KafkaOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kafka_options(&mut self) -> data_source::KafkaOptions {
        if self.has_kafka_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::KafkaOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::KafkaOptions::new()
        }
    }

    // .feast.core.DataSource.KinesisOptions kinesis_options = 14;

    pub fn kinesis_options(&self) -> &data_source::KinesisOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::KinesisOptions(ref v)) => v,
            _ => <data_source::KinesisOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kinesis_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_kinesis_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::KinesisOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kinesis_options(&mut self, v: data_source::KinesisOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::KinesisOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kinesis_options(&mut self) -> &mut data_source::KinesisOptions {
        if let ::std::option::Option::Some(data_source::Options::KinesisOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::KinesisOptions(data_source::KinesisOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::KinesisOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kinesis_options(&mut self) -> data_source::KinesisOptions {
        if self.has_kinesis_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::KinesisOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::KinesisOptions::new()
        }
    }

    // .feast.core.DataSource.RedshiftOptions redshift_options = 15;

    pub fn redshift_options(&self) -> &data_source::RedshiftOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::RedshiftOptions(ref v)) => v,
            _ => <data_source::RedshiftOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_redshift_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_redshift_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::RedshiftOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redshift_options(&mut self, v: data_source::RedshiftOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::RedshiftOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redshift_options(&mut self) -> &mut data_source::RedshiftOptions {
        if let ::std::option::Option::Some(data_source::Options::RedshiftOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::RedshiftOptions(data_source::RedshiftOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::RedshiftOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redshift_options(&mut self) -> data_source::RedshiftOptions {
        if self.has_redshift_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::RedshiftOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::RedshiftOptions::new()
        }
    }

    // .feast.core.DataSource.RequestDataOptions request_data_options = 18;

    pub fn request_data_options(&self) -> &data_source::RequestDataOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::RequestDataOptions(ref v)) => v,
            _ => <data_source::RequestDataOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_request_data_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_request_data_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::RequestDataOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_data_options(&mut self, v: data_source::RequestDataOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::RequestDataOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_data_options(&mut self) -> &mut data_source::RequestDataOptions {
        if let ::std::option::Option::Some(data_source::Options::RequestDataOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::RequestDataOptions(data_source::RequestDataOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::RequestDataOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_data_options(&mut self) -> data_source::RequestDataOptions {
        if self.has_request_data_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::RequestDataOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::RequestDataOptions::new()
        }
    }

    // .feast.core.DataSource.CustomSourceOptions custom_options = 16;

    pub fn custom_options(&self) -> &data_source::CustomSourceOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::CustomOptions(ref v)) => v,
            _ => <data_source::CustomSourceOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_custom_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_custom_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::CustomOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom_options(&mut self, v: data_source::CustomSourceOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::CustomOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom_options(&mut self) -> &mut data_source::CustomSourceOptions {
        if let ::std::option::Option::Some(data_source::Options::CustomOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::CustomOptions(data_source::CustomSourceOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::CustomOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom_options(&mut self) -> data_source::CustomSourceOptions {
        if self.has_custom_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::CustomOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::CustomSourceOptions::new()
        }
    }

    // .feast.core.DataSource.SnowflakeOptions snowflake_options = 19;

    pub fn snowflake_options(&self) -> &data_source::SnowflakeOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::SnowflakeOptions(ref v)) => v,
            _ => <data_source::SnowflakeOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_snowflake_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_snowflake_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::SnowflakeOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snowflake_options(&mut self, v: data_source::SnowflakeOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::SnowflakeOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snowflake_options(&mut self) -> &mut data_source::SnowflakeOptions {
        if let ::std::option::Option::Some(data_source::Options::SnowflakeOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::SnowflakeOptions(data_source::SnowflakeOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::SnowflakeOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snowflake_options(&mut self) -> data_source::SnowflakeOptions {
        if self.has_snowflake_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::SnowflakeOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::SnowflakeOptions::new()
        }
    }

    // .feast.core.DataSource.PushOptions push_options = 22;

    pub fn push_options(&self) -> &data_source::PushOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::PushOptions(ref v)) => v,
            _ => <data_source::PushOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_push_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_push_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::PushOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_push_options(&mut self, v: data_source::PushOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::PushOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_push_options(&mut self) -> &mut data_source::PushOptions {
        if let ::std::option::Option::Some(data_source::Options::PushOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::PushOptions(data_source::PushOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::PushOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_push_options(&mut self) -> data_source::PushOptions {
        if self.has_push_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::PushOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::PushOptions::new()
        }
    }

    // .feast.core.DataSource.SparkOptions spark_options = 27;

    pub fn spark_options(&self) -> &data_source::SparkOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::SparkOptions(ref v)) => v,
            _ => <data_source::SparkOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_spark_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_spark_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::SparkOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spark_options(&mut self, v: data_source::SparkOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::SparkOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spark_options(&mut self) -> &mut data_source::SparkOptions {
        if let ::std::option::Option::Some(data_source::Options::SparkOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::SparkOptions(data_source::SparkOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::SparkOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spark_options(&mut self) -> data_source::SparkOptions {
        if self.has_spark_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::SparkOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::SparkOptions::new()
        }
    }

    // .feast.core.DataSource.TrinoOptions trino_options = 30;

    pub fn trino_options(&self) -> &data_source::TrinoOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::TrinoOptions(ref v)) => v,
            _ => <data_source::TrinoOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_trino_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_trino_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::TrinoOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trino_options(&mut self, v: data_source::TrinoOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::TrinoOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trino_options(&mut self) -> &mut data_source::TrinoOptions {
        if let ::std::option::Option::Some(data_source::Options::TrinoOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::TrinoOptions(data_source::TrinoOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::TrinoOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trino_options(&mut self) -> data_source::TrinoOptions {
        if self.has_trino_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::TrinoOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::TrinoOptions::new()
        }
    }

    // .feast.core.DataSource.AthenaOptions athena_options = 35;

    pub fn athena_options(&self) -> &data_source::AthenaOptions {
        match self.options {
            ::std::option::Option::Some(data_source::Options::AthenaOptions(ref v)) => v,
            _ => <data_source::AthenaOptions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_athena_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_athena_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(data_source::Options::AthenaOptions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_athena_options(&mut self, v: data_source::AthenaOptions) {
        self.options = ::std::option::Option::Some(data_source::Options::AthenaOptions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_athena_options(&mut self) -> &mut data_source::AthenaOptions {
        if let ::std::option::Option::Some(data_source::Options::AthenaOptions(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(data_source::Options::AthenaOptions(data_source::AthenaOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(data_source::Options::AthenaOptions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_athena_options(&mut self) -> data_source::AthenaOptions {
        if self.has_athena_options() {
            match self.options.take() {
                ::std::option::Option::Some(data_source::Options::AthenaOptions(v)) => v,
                _ => panic!(),
            }
        } else {
            data_source::AthenaOptions::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DataSource| { &m.name },
            |m: &mut DataSource| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project",
            |m: &DataSource| { &m.project },
            |m: &mut DataSource| { &mut m.project },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &DataSource| { &m.description },
            |m: &mut DataSource| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "tags",
            |m: &DataSource| { &m.tags },
            |m: &mut DataSource| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner",
            |m: &DataSource| { &m.owner },
            |m: &mut DataSource| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &DataSource| { &m.type_ },
            |m: &mut DataSource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "field_mapping",
            |m: &DataSource| { &m.field_mapping },
            |m: &mut DataSource| { &mut m.field_mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp_field",
            |m: &DataSource| { &m.timestamp_field },
            |m: &mut DataSource| { &mut m.timestamp_field },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "date_partition_column",
            |m: &DataSource| { &m.date_partition_column },
            |m: &mut DataSource| { &mut m.date_partition_column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_timestamp_column",
            |m: &DataSource| { &m.created_timestamp_column },
            |m: &mut DataSource| { &mut m.created_timestamp_column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_source_class_type",
            |m: &DataSource| { &m.data_source_class_type },
            |m: &mut DataSource| { &mut m.data_source_class_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DataSource>(
            "batch_source",
            |m: &DataSource| { &m.batch_source },
            |m: &mut DataSource| { &mut m.batch_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::FileOptions>(
            "file_options",
            DataSource::has_file_options,
            DataSource::file_options,
            DataSource::mut_file_options,
            DataSource::set_file_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::BigQueryOptions>(
            "bigquery_options",
            DataSource::has_bigquery_options,
            DataSource::bigquery_options,
            DataSource::mut_bigquery_options,
            DataSource::set_bigquery_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::KafkaOptions>(
            "kafka_options",
            DataSource::has_kafka_options,
            DataSource::kafka_options,
            DataSource::mut_kafka_options,
            DataSource::set_kafka_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::KinesisOptions>(
            "kinesis_options",
            DataSource::has_kinesis_options,
            DataSource::kinesis_options,
            DataSource::mut_kinesis_options,
            DataSource::set_kinesis_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::RedshiftOptions>(
            "redshift_options",
            DataSource::has_redshift_options,
            DataSource::redshift_options,
            DataSource::mut_redshift_options,
            DataSource::set_redshift_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::RequestDataOptions>(
            "request_data_options",
            DataSource::has_request_data_options,
            DataSource::request_data_options,
            DataSource::mut_request_data_options,
            DataSource::set_request_data_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::CustomSourceOptions>(
            "custom_options",
            DataSource::has_custom_options,
            DataSource::custom_options,
            DataSource::mut_custom_options,
            DataSource::set_custom_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::SnowflakeOptions>(
            "snowflake_options",
            DataSource::has_snowflake_options,
            DataSource::snowflake_options,
            DataSource::mut_snowflake_options,
            DataSource::set_snowflake_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::PushOptions>(
            "push_options",
            DataSource::has_push_options,
            DataSource::push_options,
            DataSource::mut_push_options,
            DataSource::set_push_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::SparkOptions>(
            "spark_options",
            DataSource::has_spark_options,
            DataSource::spark_options,
            DataSource::mut_spark_options,
            DataSource::set_spark_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::TrinoOptions>(
            "trino_options",
            DataSource::has_trino_options,
            DataSource::trino_options,
            DataSource::mut_trino_options,
            DataSource::set_trino_options,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, data_source::AthenaOptions>(
            "athena_options",
            DataSource::has_athena_options,
            DataSource::athena_options,
            DataSource::mut_athena_options,
            DataSource::set_athena_options,
        ));
        oneofs.push(data_source::Options::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataSource>(
            "DataSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataSource {
    const NAME: &'static str = "DataSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                162 => {
                    self.name = is.read_string()?;
                },
                170 => {
                    self.project = is.read_string()?;
                },
                186 => {
                    self.description = is.read_string()?;
                },
                194 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.tags.insert(key, value);
                },
                202 => {
                    self.owner = is.read_string()?;
                },
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.field_mapping.insert(key, value);
                },
                26 => {
                    self.timestamp_field = is.read_string()?;
                },
                34 => {
                    self.date_partition_column = is.read_string()?;
                },
                42 => {
                    self.created_timestamp_column = is.read_string()?;
                },
                138 => {
                    self.data_source_class_type = is.read_string()?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.batch_source)?;
                },
                90 => {
                    self.options = ::std::option::Option::Some(data_source::Options::FileOptions(is.read_message()?));
                },
                98 => {
                    self.options = ::std::option::Option::Some(data_source::Options::BigqueryOptions(is.read_message()?));
                },
                106 => {
                    self.options = ::std::option::Option::Some(data_source::Options::KafkaOptions(is.read_message()?));
                },
                114 => {
                    self.options = ::std::option::Option::Some(data_source::Options::KinesisOptions(is.read_message()?));
                },
                122 => {
                    self.options = ::std::option::Option::Some(data_source::Options::RedshiftOptions(is.read_message()?));
                },
                146 => {
                    self.options = ::std::option::Option::Some(data_source::Options::RequestDataOptions(is.read_message()?));
                },
                130 => {
                    self.options = ::std::option::Option::Some(data_source::Options::CustomOptions(is.read_message()?));
                },
                154 => {
                    self.options = ::std::option::Option::Some(data_source::Options::SnowflakeOptions(is.read_message()?));
                },
                178 => {
                    self.options = ::std::option::Option::Some(data_source::Options::PushOptions(is.read_message()?));
                },
                218 => {
                    self.options = ::std::option::Option::Some(data_source::Options::SparkOptions(is.read_message()?));
                },
                242 => {
                    self.options = ::std::option::Option::Some(data_source::Options::TrinoOptions(is.read_message()?));
                },
                282 => {
                    self.options = ::std::option::Option::Some(data_source::Options::AthenaOptions(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.name);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.project);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.description);
        }
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.owner);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(data_source::SourceType::INVALID) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        for (k, v) in &self.field_mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.timestamp_field.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.timestamp_field);
        }
        if !self.date_partition_column.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.date_partition_column);
        }
        if !self.created_timestamp_column.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.created_timestamp_column);
        }
        if !self.data_source_class_type.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.data_source_class_type);
        }
        if let Some(v) = self.batch_source.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.options {
            match v {
                &data_source::Options::FileOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::BigqueryOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::KafkaOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::KinesisOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::RedshiftOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::RequestDataOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::CustomOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::SnowflakeOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::PushOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::SparkOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::TrinoOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Options::AthenaOptions(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(20, &self.name)?;
        }
        if !self.project.is_empty() {
            os.write_string(21, &self.project)?;
        }
        if !self.description.is_empty() {
            os.write_string(23, &self.description)?;
        }
        for (k, v) in &self.tags {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(194)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.owner.is_empty() {
            os.write_string(25, &self.owner)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(data_source::SourceType::INVALID) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for (k, v) in &self.field_mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.timestamp_field.is_empty() {
            os.write_string(3, &self.timestamp_field)?;
        }
        if !self.date_partition_column.is_empty() {
            os.write_string(4, &self.date_partition_column)?;
        }
        if !self.created_timestamp_column.is_empty() {
            os.write_string(5, &self.created_timestamp_column)?;
        }
        if !self.data_source_class_type.is_empty() {
            os.write_string(17, &self.data_source_class_type)?;
        }
        if let Some(v) = self.batch_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.options {
            match v {
                &data_source::Options::FileOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &data_source::Options::BigqueryOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &data_source::Options::KafkaOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &data_source::Options::KinesisOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &data_source::Options::RedshiftOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &data_source::Options::RequestDataOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &data_source::Options::CustomOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &data_source::Options::SnowflakeOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &data_source::Options::PushOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &data_source::Options::SparkOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                },
                &data_source::Options::TrinoOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                },
                &data_source::Options::AthenaOptions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataSource {
        DataSource::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.project.clear();
        self.description.clear();
        self.tags.clear();
        self.owner.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(data_source::SourceType::INVALID);
        self.field_mapping.clear();
        self.timestamp_field.clear();
        self.date_partition_column.clear();
        self.created_timestamp_column.clear();
        self.data_source_class_type.clear();
        self.batch_source.clear();
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataSource {
        static instance: ::protobuf::rt::Lazy<DataSource> = ::protobuf::rt::Lazy::new();
        instance.get(DataSource::new)
    }
}

impl ::protobuf::MessageFull for DataSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DataSource`
pub mod data_source {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:feast.core.DataSource.options)
    pub enum Options {
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.file_options)
        FileOptions(FileOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.bigquery_options)
        BigqueryOptions(BigQueryOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.kafka_options)
        KafkaOptions(KafkaOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.kinesis_options)
        KinesisOptions(KinesisOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.redshift_options)
        RedshiftOptions(RedshiftOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.request_data_options)
        RequestDataOptions(RequestDataOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.custom_options)
        CustomOptions(CustomSourceOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.snowflake_options)
        SnowflakeOptions(SnowflakeOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.push_options)
        PushOptions(PushOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.spark_options)
        SparkOptions(SparkOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.trino_options)
        TrinoOptions(TrinoOptions),
        // @@protoc_insertion_point(oneof_field:feast.core.DataSource.athena_options)
        AthenaOptions(AthenaOptions),
    }

    impl ::protobuf::Oneof for Options {
    }

    impl ::protobuf::OneofFull for Options {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DataSource as ::protobuf::MessageFull>::descriptor().oneof_by_name("options").unwrap()).clone()
        }
    }

    impl Options {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Options>("options")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.FileOptions)
    pub struct FileOptions {
        // message fields
        // @@protoc_insertion_point(field:feast.core.DataSource.FileOptions.file_format)
        pub file_format: ::protobuf::MessageField<super::super::DataFormat::FileFormat>,
        // @@protoc_insertion_point(field:feast.core.DataSource.FileOptions.uri)
        pub uri: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.FileOptions.s3_endpoint_override)
        pub s3_endpoint_override: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.FileOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FileOptions {
        fn default() -> &'a FileOptions {
            <FileOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl FileOptions {
        pub fn new() -> FileOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::DataFormat::FileFormat>(
                "file_format",
                |m: &FileOptions| { &m.file_format },
                |m: &mut FileOptions| { &mut m.file_format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "uri",
                |m: &FileOptions| { &m.uri },
                |m: &mut FileOptions| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "s3_endpoint_override",
                |m: &FileOptions| { &m.s3_endpoint_override },
                |m: &mut FileOptions| { &mut m.s3_endpoint_override },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileOptions>(
                "DataSource.FileOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FileOptions {
        const NAME: &'static str = "FileOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.file_format)?;
                    },
                    18 => {
                        self.uri = is.read_string()?;
                    },
                    26 => {
                        self.s3_endpoint_override = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.file_format.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.uri.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.uri);
            }
            if !self.s3_endpoint_override.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.s3_endpoint_override);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.file_format.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if !self.uri.is_empty() {
                os.write_string(2, &self.uri)?;
            }
            if !self.s3_endpoint_override.is_empty() {
                os.write_string(3, &self.s3_endpoint_override)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FileOptions {
            FileOptions::new()
        }

        fn clear(&mut self) {
            self.file_format.clear();
            self.uri.clear();
            self.s3_endpoint_override.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FileOptions {
            static instance: FileOptions = FileOptions {
                file_format: ::protobuf::MessageField::none(),
                uri: ::std::string::String::new(),
                s3_endpoint_override: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FileOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.FileOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FileOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FileOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.BigQueryOptions)
    pub struct BigQueryOptions {
        // message fields
        // @@protoc_insertion_point(field:feast.core.DataSource.BigQueryOptions.table)
        pub table: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.BigQueryOptions.query)
        pub query: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.BigQueryOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BigQueryOptions {
        fn default() -> &'a BigQueryOptions {
            <BigQueryOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl BigQueryOptions {
        pub fn new() -> BigQueryOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &BigQueryOptions| { &m.table },
                |m: &mut BigQueryOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &BigQueryOptions| { &m.query },
                |m: &mut BigQueryOptions| { &mut m.query },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BigQueryOptions>(
                "DataSource.BigQueryOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BigQueryOptions {
        const NAME: &'static str = "BigQueryOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BigQueryOptions {
            BigQueryOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BigQueryOptions {
            static instance: BigQueryOptions = BigQueryOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BigQueryOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.BigQueryOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BigQueryOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BigQueryOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a file
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.TrinoOptions)
    pub struct TrinoOptions {
        // message fields
        // @@protoc_insertion_point(field:feast.core.DataSource.TrinoOptions.table)
        pub table: ::std::string::String,
        ///  Target URL of file to retrieve and source features from.
        ///  s3://path/to/file for AWS S3 storage
        ///  gs://path/to/file for GCP GCS storage
        ///  file:///path/to/file for local storage
        // @@protoc_insertion_point(field:feast.core.DataSource.TrinoOptions.query)
        pub query: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.TrinoOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TrinoOptions {
        fn default() -> &'a TrinoOptions {
            <TrinoOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl TrinoOptions {
        pub fn new() -> TrinoOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &TrinoOptions| { &m.table },
                |m: &mut TrinoOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &TrinoOptions| { &m.query },
                |m: &mut TrinoOptions| { &mut m.query },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrinoOptions>(
                "DataSource.TrinoOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TrinoOptions {
        const NAME: &'static str = "TrinoOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TrinoOptions {
            TrinoOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TrinoOptions {
            static instance: TrinoOptions = TrinoOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TrinoOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.TrinoOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TrinoOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TrinoOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a BigQuery Query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.KafkaOptions)
    pub struct KafkaOptions {
        // message fields
        ///  Full table reference in the form of [project:dataset.table]
        // @@protoc_insertion_point(field:feast.core.DataSource.KafkaOptions.kafka_bootstrap_servers)
        pub kafka_bootstrap_servers: ::std::string::String,
        ///  SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        ///  entity columns
        // @@protoc_insertion_point(field:feast.core.DataSource.KafkaOptions.topic)
        pub topic: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.KafkaOptions.message_format)
        pub message_format: ::protobuf::MessageField<super::super::DataFormat::StreamFormat>,
        // @@protoc_insertion_point(field:feast.core.DataSource.KafkaOptions.watermark_delay_threshold)
        pub watermark_delay_threshold: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.KafkaOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KafkaOptions {
        fn default() -> &'a KafkaOptions {
            <KafkaOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl KafkaOptions {
        pub fn new() -> KafkaOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "kafka_bootstrap_servers",
                |m: &KafkaOptions| { &m.kafka_bootstrap_servers },
                |m: &mut KafkaOptions| { &mut m.kafka_bootstrap_servers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "topic",
                |m: &KafkaOptions| { &m.topic },
                |m: &mut KafkaOptions| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::DataFormat::StreamFormat>(
                "message_format",
                |m: &KafkaOptions| { &m.message_format },
                |m: &mut KafkaOptions| { &mut m.message_format },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "watermark_delay_threshold",
                |m: &KafkaOptions| { &m.watermark_delay_threshold },
                |m: &mut KafkaOptions| { &mut m.watermark_delay_threshold },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KafkaOptions>(
                "DataSource.KafkaOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KafkaOptions {
        const NAME: &'static str = "KafkaOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.kafka_bootstrap_servers = is.read_string()?;
                    },
                    18 => {
                        self.topic = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.message_format)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.watermark_delay_threshold)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.kafka_bootstrap_servers.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.kafka_bootstrap_servers);
            }
            if !self.topic.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.topic);
            }
            if let Some(v) = self.message_format.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.watermark_delay_threshold.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.kafka_bootstrap_servers.is_empty() {
                os.write_string(1, &self.kafka_bootstrap_servers)?;
            }
            if !self.topic.is_empty() {
                os.write_string(2, &self.topic)?;
            }
            if let Some(v) = self.message_format.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.watermark_delay_threshold.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KafkaOptions {
            KafkaOptions::new()
        }

        fn clear(&mut self) {
            self.kafka_bootstrap_servers.clear();
            self.topic.clear();
            self.message_format.clear();
            self.watermark_delay_threshold.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KafkaOptions {
            static instance: KafkaOptions = KafkaOptions {
                kafka_bootstrap_servers: ::std::string::String::new(),
                topic: ::std::string::String::new(),
                message_format: ::protobuf::MessageField::none(),
                watermark_delay_threshold: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KafkaOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.KafkaOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KafkaOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KafkaOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a Trino Query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.KinesisOptions)
    pub struct KinesisOptions {
        // message fields
        ///  Full table reference in the form of [project:dataset.table]
        // @@protoc_insertion_point(field:feast.core.DataSource.KinesisOptions.region)
        pub region: ::std::string::String,
        ///  SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        ///  entity columns
        // @@protoc_insertion_point(field:feast.core.DataSource.KinesisOptions.stream_name)
        pub stream_name: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.KinesisOptions.record_format)
        pub record_format: ::protobuf::MessageField<super::super::DataFormat::StreamFormat>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.KinesisOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KinesisOptions {
        fn default() -> &'a KinesisOptions {
            <KinesisOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl KinesisOptions {
        pub fn new() -> KinesisOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "region",
                |m: &KinesisOptions| { &m.region },
                |m: &mut KinesisOptions| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stream_name",
                |m: &KinesisOptions| { &m.stream_name },
                |m: &mut KinesisOptions| { &mut m.stream_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::DataFormat::StreamFormat>(
                "record_format",
                |m: &KinesisOptions| { &m.record_format },
                |m: &mut KinesisOptions| { &mut m.record_format },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KinesisOptions>(
                "DataSource.KinesisOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KinesisOptions {
        const NAME: &'static str = "KinesisOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.region = is.read_string()?;
                    },
                    18 => {
                        self.stream_name = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.record_format)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.region.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.region);
            }
            if !self.stream_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.stream_name);
            }
            if let Some(v) = self.record_format.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.region.is_empty() {
                os.write_string(1, &self.region)?;
            }
            if !self.stream_name.is_empty() {
                os.write_string(2, &self.stream_name)?;
            }
            if let Some(v) = self.record_format.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KinesisOptions {
            KinesisOptions::new()
        }

        fn clear(&mut self) {
            self.region.clear();
            self.stream_name.clear();
            self.record_format.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KinesisOptions {
            static instance: KinesisOptions = KinesisOptions {
                region: ::std::string::String::new(),
                stream_name: ::std::string::String::new(),
                record_format: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KinesisOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.KinesisOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KinesisOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KinesisOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from Kafka messages.
    ///  Each message should be a Protobuf that can be decoded with the generated
    ///  Java Protobuf class at the given class path
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.RedshiftOptions)
    pub struct RedshiftOptions {
        // message fields
        ///  Comma separated list of Kafka bootstrap servers. Used for feature tables without a defined source host[:port]]
        // @@protoc_insertion_point(field:feast.core.DataSource.RedshiftOptions.table)
        pub table: ::std::string::String,
        ///  Kafka topic to collect feature data from.
        // @@protoc_insertion_point(field:feast.core.DataSource.RedshiftOptions.query)
        pub query: ::std::string::String,
        ///  Defines the stream data format encoding feature/entity data in Kafka messages.
        // @@protoc_insertion_point(field:feast.core.DataSource.RedshiftOptions.schema)
        pub schema: ::std::string::String,
        ///  Watermark delay threshold for stream data
        // @@protoc_insertion_point(field:feast.core.DataSource.RedshiftOptions.database)
        pub database: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.RedshiftOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RedshiftOptions {
        fn default() -> &'a RedshiftOptions {
            <RedshiftOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl RedshiftOptions {
        pub fn new() -> RedshiftOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &RedshiftOptions| { &m.table },
                |m: &mut RedshiftOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &RedshiftOptions| { &m.query },
                |m: &mut RedshiftOptions| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "schema",
                |m: &RedshiftOptions| { &m.schema },
                |m: &mut RedshiftOptions| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "database",
                |m: &RedshiftOptions| { &m.database },
                |m: &mut RedshiftOptions| { &mut m.database },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedshiftOptions>(
                "DataSource.RedshiftOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RedshiftOptions {
        const NAME: &'static str = "RedshiftOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    26 => {
                        self.schema = is.read_string()?;
                    },
                    34 => {
                        self.database = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            if !self.schema.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.schema);
            }
            if !self.database.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.database);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            if !self.schema.is_empty() {
                os.write_string(3, &self.schema)?;
            }
            if !self.database.is_empty() {
                os.write_string(4, &self.database)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RedshiftOptions {
            RedshiftOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.schema.clear();
            self.database.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RedshiftOptions {
            static instance: RedshiftOptions = RedshiftOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                schema: ::std::string::String::new(),
                database: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RedshiftOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.RedshiftOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RedshiftOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RedshiftOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from Kinesis records.
    ///  Each record should be a Protobuf that can be decoded with the generated
    ///  Java Protobuf class at the given class path
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.AthenaOptions)
    pub struct AthenaOptions {
        // message fields
        ///  AWS region of the Kinesis stream
        // @@protoc_insertion_point(field:feast.core.DataSource.AthenaOptions.table)
        pub table: ::std::string::String,
        ///  Name of the Kinesis stream to obtain feature data from.
        // @@protoc_insertion_point(field:feast.core.DataSource.AthenaOptions.query)
        pub query: ::std::string::String,
        ///  Defines the data format encoding the feature/entity data in Kinesis records.
        ///  Kinesis Data Sources support Avro and Proto as data formats.
        // @@protoc_insertion_point(field:feast.core.DataSource.AthenaOptions.database)
        pub database: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.AthenaOptions.data_source)
        pub data_source: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.AthenaOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AthenaOptions {
        fn default() -> &'a AthenaOptions {
            <AthenaOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl AthenaOptions {
        pub fn new() -> AthenaOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &AthenaOptions| { &m.table },
                |m: &mut AthenaOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &AthenaOptions| { &m.query },
                |m: &mut AthenaOptions| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "database",
                |m: &AthenaOptions| { &m.database },
                |m: &mut AthenaOptions| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data_source",
                |m: &AthenaOptions| { &m.data_source },
                |m: &mut AthenaOptions| { &mut m.data_source },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AthenaOptions>(
                "DataSource.AthenaOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AthenaOptions {
        const NAME: &'static str = "AthenaOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    26 => {
                        self.database = is.read_string()?;
                    },
                    34 => {
                        self.data_source = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            if !self.database.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.database);
            }
            if !self.data_source.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.data_source);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            if !self.database.is_empty() {
                os.write_string(3, &self.database)?;
            }
            if !self.data_source.is_empty() {
                os.write_string(4, &self.data_source)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AthenaOptions {
            AthenaOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.database.clear();
            self.data_source.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AthenaOptions {
            static instance: AthenaOptions = AthenaOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                database: ::std::string::String::new(),
                data_source: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AthenaOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.AthenaOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AthenaOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AthenaOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a Redshift Query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.SnowflakeOptions)
    pub struct SnowflakeOptions {
        // message fields
        ///  Redshift table name
        // @@protoc_insertion_point(field:feast.core.DataSource.SnowflakeOptions.table)
        pub table: ::std::string::String,
        ///  SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        ///  entity columns
        // @@protoc_insertion_point(field:feast.core.DataSource.SnowflakeOptions.query)
        pub query: ::std::string::String,
        ///  Redshift schema name
        // @@protoc_insertion_point(field:feast.core.DataSource.SnowflakeOptions.schema)
        pub schema: ::std::string::String,
        ///  Redshift database name
        // @@protoc_insertion_point(field:feast.core.DataSource.SnowflakeOptions.database)
        pub database: ::std::string::String,
        // @@protoc_insertion_point(field:feast.core.DataSource.SnowflakeOptions.warehouse)
        pub warehouse: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.SnowflakeOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SnowflakeOptions {
        fn default() -> &'a SnowflakeOptions {
            <SnowflakeOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl SnowflakeOptions {
        pub fn new() -> SnowflakeOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &SnowflakeOptions| { &m.table },
                |m: &mut SnowflakeOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &SnowflakeOptions| { &m.query },
                |m: &mut SnowflakeOptions| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "schema",
                |m: &SnowflakeOptions| { &m.schema },
                |m: &mut SnowflakeOptions| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "database",
                |m: &SnowflakeOptions| { &m.database },
                |m: &mut SnowflakeOptions| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "warehouse",
                |m: &SnowflakeOptions| { &m.warehouse },
                |m: &mut SnowflakeOptions| { &mut m.warehouse },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SnowflakeOptions>(
                "DataSource.SnowflakeOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SnowflakeOptions {
        const NAME: &'static str = "SnowflakeOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    26 => {
                        self.schema = is.read_string()?;
                    },
                    34 => {
                        self.database = is.read_string()?;
                    },
                    42 => {
                        self.warehouse = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            if !self.schema.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.schema);
            }
            if !self.database.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.database);
            }
            if !self.warehouse.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.warehouse);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            if !self.schema.is_empty() {
                os.write_string(3, &self.schema)?;
            }
            if !self.database.is_empty() {
                os.write_string(4, &self.database)?;
            }
            if !self.warehouse.is_empty() {
                os.write_string(5, &self.warehouse)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SnowflakeOptions {
            SnowflakeOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.schema.clear();
            self.database.clear();
            self.warehouse.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SnowflakeOptions {
            static instance: SnowflakeOptions = SnowflakeOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                schema: ::std::string::String::new(),
                database: ::std::string::String::new(),
                warehouse: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SnowflakeOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.SnowflakeOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SnowflakeOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SnowflakeOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a Athena Query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.SparkOptions)
    pub struct SparkOptions {
        // message fields
        ///  Athena table name
        // @@protoc_insertion_point(field:feast.core.DataSource.SparkOptions.table)
        pub table: ::std::string::String,
        ///  SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        ///  entity columns
        // @@protoc_insertion_point(field:feast.core.DataSource.SparkOptions.query)
        pub query: ::std::string::String,
        ///  Athena database name
        // @@protoc_insertion_point(field:feast.core.DataSource.SparkOptions.path)
        pub path: ::std::string::String,
        ///  Athena schema name
        // @@protoc_insertion_point(field:feast.core.DataSource.SparkOptions.file_format)
        pub file_format: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.SparkOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SparkOptions {
        fn default() -> &'a SparkOptions {
            <SparkOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl SparkOptions {
        pub fn new() -> SparkOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "table",
                |m: &SparkOptions| { &m.table },
                |m: &mut SparkOptions| { &mut m.table },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query",
                |m: &SparkOptions| { &m.query },
                |m: &mut SparkOptions| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "path",
                |m: &SparkOptions| { &m.path },
                |m: &mut SparkOptions| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "file_format",
                |m: &SparkOptions| { &m.file_format },
                |m: &mut SparkOptions| { &mut m.file_format },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SparkOptions>(
                "DataSource.SparkOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SparkOptions {
        const NAME: &'static str = "SparkOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table = is.read_string()?;
                    },
                    18 => {
                        self.query = is.read_string()?;
                    },
                    26 => {
                        self.path = is.read_string()?;
                    },
                    34 => {
                        self.file_format = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.table.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.table);
            }
            if !self.query.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query);
            }
            if !self.path.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.path);
            }
            if !self.file_format.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.file_format);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.table.is_empty() {
                os.write_string(1, &self.table)?;
            }
            if !self.query.is_empty() {
                os.write_string(2, &self.query)?;
            }
            if !self.path.is_empty() {
                os.write_string(3, &self.path)?;
            }
            if !self.file_format.is_empty() {
                os.write_string(4, &self.file_format)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SparkOptions {
            SparkOptions::new()
        }

        fn clear(&mut self) {
            self.table.clear();
            self.query.clear();
            self.path.clear();
            self.file_format.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SparkOptions {
            static instance: SparkOptions = SparkOptions {
                table: ::std::string::String::new(),
                query: ::std::string::String::new(),
                path: ::std::string::String::new(),
                file_format: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SparkOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.SparkOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SparkOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SparkOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a Snowflake Query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.CustomSourceOptions)
    pub struct CustomSourceOptions {
        // message fields
        ///  Snowflake table name
        // @@protoc_insertion_point(field:feast.core.DataSource.CustomSourceOptions.configuration)
        pub configuration: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.CustomSourceOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomSourceOptions {
        fn default() -> &'a CustomSourceOptions {
            <CustomSourceOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl CustomSourceOptions {
        pub fn new() -> CustomSourceOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "configuration",
                |m: &CustomSourceOptions| { &m.configuration },
                |m: &mut CustomSourceOptions| { &mut m.configuration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomSourceOptions>(
                "DataSource.CustomSourceOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CustomSourceOptions {
        const NAME: &'static str = "CustomSourceOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.configuration = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.configuration.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.configuration);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.configuration.is_empty() {
                os.write_bytes(1, &self.configuration)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomSourceOptions {
            CustomSourceOptions::new()
        }

        fn clear(&mut self) {
            self.configuration.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomSourceOptions {
            static instance: CustomSourceOptions = CustomSourceOptions {
                configuration: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CustomSourceOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.CustomSourceOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CustomSourceOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CustomSourceOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines options for DataSource that sources features from a spark table/query
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.RequestDataOptions)
    pub struct RequestDataOptions {
        // message fields
        ///  Table name
        // @@protoc_insertion_point(field:feast.core.DataSource.RequestDataOptions.deprecated_schema)
        pub deprecated_schema: ::std::collections::HashMap<::std::string::String, ::protobuf::EnumOrUnknown<super::super::Value::value_type::Enum>>,
        ///  Spark SQl query that returns the table, this is an alternative to `table`
        // @@protoc_insertion_point(field:feast.core.DataSource.RequestDataOptions.schema)
        pub schema: ::std::vec::Vec<super::super::Feature::FeatureSpecV2>,
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.RequestDataOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RequestDataOptions {
        fn default() -> &'a RequestDataOptions {
            <RequestDataOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl RequestDataOptions {
        pub fn new() -> RequestDataOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
                "deprecated_schema",
                |m: &RequestDataOptions| { &m.deprecated_schema },
                |m: &mut RequestDataOptions| { &mut m.deprecated_schema },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "schema",
                |m: &RequestDataOptions| { &m.schema },
                |m: &mut RequestDataOptions| { &mut m.schema },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestDataOptions>(
                "DataSource.RequestDataOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RequestDataOptions {
        const NAME: &'static str = "RequestDataOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                16 => value = is.read_enum_or_unknown()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.deprecated_schema.insert(key, value);
                    },
                    26 => {
                        self.schema.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for (k, v) in &self.deprecated_schema {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::int32_size(2, v.value());
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.schema {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for (k, v) in &self.deprecated_schema {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::int32_size(2, v.value());
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
            };
            for v in &self.schema {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RequestDataOptions {
            RequestDataOptions::new()
        }

        fn clear(&mut self) {
            self.deprecated_schema.clear();
            self.schema.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RequestDataOptions {
            static instance: ::protobuf::rt::Lazy<RequestDataOptions> = ::protobuf::rt::Lazy::new();
            instance.get(RequestDataOptions::new)
        }
    }

    impl ::protobuf::MessageFull for RequestDataOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.RequestDataOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RequestDataOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RequestDataOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Defines configuration for custom third-party data sources.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:feast.core.DataSource.PushOptions)
    pub struct PushOptions {
        // special fields
        // @@protoc_insertion_point(special_field:feast.core.DataSource.PushOptions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PushOptions {
        fn default() -> &'a PushOptions {
            <PushOptions as ::protobuf::Message>::default_instance()
        }
    }

    impl PushOptions {
        pub fn new() -> PushOptions {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushOptions>(
                "DataSource.PushOptions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PushOptions {
        const NAME: &'static str = "PushOptions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PushOptions {
            PushOptions::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PushOptions {
            static instance: PushOptions = PushOptions {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PushOptions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataSource.PushOptions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PushOptions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PushOptions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Type of Data Source.
    ///  Next available id: 12
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:feast.core.DataSource.SourceType)
    pub enum SourceType {
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_FILE)
        BATCH_FILE = 1,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_SNOWFLAKE)
        BATCH_SNOWFLAKE = 8,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_BIGQUERY)
        BATCH_BIGQUERY = 2,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_REDSHIFT)
        BATCH_REDSHIFT = 5,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.STREAM_KAFKA)
        STREAM_KAFKA = 3,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.STREAM_KINESIS)
        STREAM_KINESIS = 4,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.CUSTOM_SOURCE)
        CUSTOM_SOURCE = 6,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.REQUEST_SOURCE)
        REQUEST_SOURCE = 7,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.PUSH_SOURCE)
        PUSH_SOURCE = 9,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_TRINO)
        BATCH_TRINO = 10,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_SPARK)
        BATCH_SPARK = 11,
        // @@protoc_insertion_point(enum_value:feast.core.DataSource.SourceType.BATCH_ATHENA)
        BATCH_ATHENA = 12,
    }

    impl ::protobuf::Enum for SourceType {
        const NAME: &'static str = "SourceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SourceType> {
            match value {
                0 => ::std::option::Option::Some(SourceType::INVALID),
                1 => ::std::option::Option::Some(SourceType::BATCH_FILE),
                8 => ::std::option::Option::Some(SourceType::BATCH_SNOWFLAKE),
                2 => ::std::option::Option::Some(SourceType::BATCH_BIGQUERY),
                5 => ::std::option::Option::Some(SourceType::BATCH_REDSHIFT),
                3 => ::std::option::Option::Some(SourceType::STREAM_KAFKA),
                4 => ::std::option::Option::Some(SourceType::STREAM_KINESIS),
                6 => ::std::option::Option::Some(SourceType::CUSTOM_SOURCE),
                7 => ::std::option::Option::Some(SourceType::REQUEST_SOURCE),
                9 => ::std::option::Option::Some(SourceType::PUSH_SOURCE),
                10 => ::std::option::Option::Some(SourceType::BATCH_TRINO),
                11 => ::std::option::Option::Some(SourceType::BATCH_SPARK),
                12 => ::std::option::Option::Some(SourceType::BATCH_ATHENA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SourceType] = &[
            SourceType::INVALID,
            SourceType::BATCH_FILE,
            SourceType::BATCH_SNOWFLAKE,
            SourceType::BATCH_BIGQUERY,
            SourceType::BATCH_REDSHIFT,
            SourceType::STREAM_KAFKA,
            SourceType::STREAM_KINESIS,
            SourceType::CUSTOM_SOURCE,
            SourceType::REQUEST_SOURCE,
            SourceType::PUSH_SOURCE,
            SourceType::BATCH_TRINO,
            SourceType::BATCH_SPARK,
            SourceType::BATCH_ATHENA,
        ];
    }

    impl ::protobuf::EnumFull for SourceType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DataSource.SourceType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                SourceType::INVALID => 0,
                SourceType::BATCH_FILE => 1,
                SourceType::BATCH_SNOWFLAKE => 2,
                SourceType::BATCH_BIGQUERY => 3,
                SourceType::BATCH_REDSHIFT => 4,
                SourceType::STREAM_KAFKA => 5,
                SourceType::STREAM_KINESIS => 6,
                SourceType::CUSTOM_SOURCE => 7,
                SourceType::REQUEST_SOURCE => 8,
                SourceType::PUSH_SOURCE => 9,
                SourceType::BATCH_TRINO => 10,
                SourceType::BATCH_SPARK => 11,
                SourceType::BATCH_ATHENA => 12,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SourceType {
        fn default() -> Self {
            SourceType::INVALID
        }
    }

    impl SourceType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SourceType>("DataSource.SourceType")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bfeast/core/DataSource.proto\x12\nfeast.core\x1a\x1egoogle/protobuf\
    /duration.proto\x1a\x1bfeast/core/DataFormat.proto\x1a\x17feast/types/Va\
    lue.proto\x1a\x18feast/core/Feature.proto\"\xf5\x1a\n\nDataSource\x12\
    \x12\n\x04name\x18\x14\x20\x01(\tR\x04name\x12\x18\n\x07project\x18\x15\
    \x20\x01(\tR\x07project\x12\x20\n\x0bdescription\x18\x17\x20\x01(\tR\x0b\
    description\x124\n\x04tags\x18\x18\x20\x03(\x0b2\x20.feast.core.DataSour\
    ce.TagsEntryR\x04tags\x12\x14\n\x05owner\x18\x19\x20\x01(\tR\x05owner\
    \x125\n\x04type\x18\x01\x20\x01(\x0e2!.feast.core.DataSource.SourceTypeR\
    \x04type\x12M\n\rfield_mapping\x18\x02\x20\x03(\x0b2(.feast.core.DataSou\
    rce.FieldMappingEntryR\x0cfieldMapping\x12'\n\x0ftimestamp_field\x18\x03\
    \x20\x01(\tR\x0etimestampField\x122\n\x15date_partition_column\x18\x04\
    \x20\x01(\tR\x13datePartitionColumn\x128\n\x18created_timestamp_column\
    \x18\x05\x20\x01(\tR\x16createdTimestampColumn\x123\n\x16data_source_cla\
    ss_type\x18\x11\x20\x01(\tR\x13dataSourceClassType\x129\n\x0cbatch_sourc\
    e\x18\x1a\x20\x01(\x0b2\x16.feast.core.DataSourceR\x0bbatchSource\x12G\n\
    \x0cfile_options\x18\x0b\x20\x01(\x0b2\".feast.core.DataSource.FileOptio\
    nsH\0R\x0bfileOptions\x12S\n\x10bigquery_options\x18\x0c\x20\x01(\x0b2&.\
    feast.core.DataSource.BigQueryOptionsH\0R\x0fbigqueryOptions\x12J\n\rkaf\
    ka_options\x18\r\x20\x01(\x0b2#.feast.core.DataSource.KafkaOptionsH\0R\
    \x0ckafkaOptions\x12P\n\x0fkinesis_options\x18\x0e\x20\x01(\x0b2%.feast.\
    core.DataSource.KinesisOptionsH\0R\x0ekinesisOptions\x12S\n\x10redshift_\
    options\x18\x0f\x20\x01(\x0b2&.feast.core.DataSource.RedshiftOptionsH\0R\
    \x0fredshiftOptions\x12]\n\x14request_data_options\x18\x12\x20\x01(\x0b2\
    ).feast.core.DataSource.RequestDataOptionsH\0R\x12requestDataOptions\x12\
    S\n\x0ecustom_options\x18\x10\x20\x01(\x0b2*.feast.core.DataSource.Custo\
    mSourceOptionsH\0R\rcustomOptions\x12V\n\x11snowflake_options\x18\x13\
    \x20\x01(\x0b2'.feast.core.DataSource.SnowflakeOptionsH\0R\x10snowflakeO\
    ptions\x12G\n\x0cpush_options\x18\x16\x20\x01(\x0b2\".feast.core.DataSou\
    rce.PushOptionsH\0R\x0bpushOptions\x12J\n\rspark_options\x18\x1b\x20\x01\
    (\x0b2#.feast.core.DataSource.SparkOptionsH\0R\x0csparkOptions\x12J\n\rt\
    rino_options\x18\x1e\x20\x01(\x0b2#.feast.core.DataSource.TrinoOptionsH\
    \0R\x0ctrinoOptions\x12M\n\x0eathena_options\x18#\x20\x01(\x0b2$.feast.c\
    ore.DataSource.AthenaOptionsH\0R\rathenaOptions\x1a7\n\tTagsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a?\n\x11FieldMappingEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\x8a\x01\n\x0bFileOptions\x127\n\x0bfile_format\x18\x01\
    \x20\x01(\x0b2\x16.feast.core.FileFormatR\nfileFormat\x12\x10\n\x03uri\
    \x18\x02\x20\x01(\tR\x03uri\x120\n\x14s3_endpoint_override\x18\x03\x20\
    \x01(\tR\x12s3EndpointOverride\x1a=\n\x0fBigQueryOptions\x12\x14\n\x05ta\
    ble\x18\x01\x20\x01(\tR\x05table\x12\x14\n\x05query\x18\x02\x20\x01(\tR\
    \x05query\x1a:\n\x0cTrinoOptions\x12\x14\n\x05table\x18\x01\x20\x01(\tR\
    \x05table\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05query\x1a\xf4\x01\n\
    \x0cKafkaOptions\x126\n\x17kafka_bootstrap_servers\x18\x01\x20\x01(\tR\
    \x15kafkaBootstrapServers\x12\x14\n\x05topic\x18\x02\x20\x01(\tR\x05topi\
    c\x12?\n\x0emessage_format\x18\x03\x20\x01(\x0b2\x18.feast.core.StreamFo\
    rmatR\rmessageFormat\x12U\n\x19watermark_delay_threshold\x18\x04\x20\x01\
    (\x0b2\x19.google.protobuf.DurationR\x17watermarkDelayThreshold\x1a\x88\
    \x01\n\x0eKinesisOptions\x12\x16\n\x06region\x18\x01\x20\x01(\tR\x06regi\
    on\x12\x1f\n\x0bstream_name\x18\x02\x20\x01(\tR\nstreamName\x12=\n\rreco\
    rd_format\x18\x03\x20\x01(\x0b2\x18.feast.core.StreamFormatR\x0crecordFo\
    rmat\x1aq\n\x0fRedshiftOptions\x12\x14\n\x05table\x18\x01\x20\x01(\tR\
    \x05table\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05query\x12\x16\n\x06s\
    chema\x18\x03\x20\x01(\tR\x06schema\x12\x1a\n\x08database\x18\x04\x20\
    \x01(\tR\x08database\x1ax\n\rAthenaOptions\x12\x14\n\x05table\x18\x01\
    \x20\x01(\tR\x05table\x12\x14\n\x05query\x18\x02\x20\x01(\tR\x05query\
    \x12\x1a\n\x08database\x18\x03\x20\x01(\tR\x08database\x12\x1f\n\x0bdata\
    _source\x18\x04\x20\x01(\tR\ndataSource\x1a\x90\x01\n\x10SnowflakeOption\
    s\x12\x14\n\x05table\x18\x01\x20\x01(\tR\x05table\x12\x14\n\x05query\x18\
    \x02\x20\x01(\tR\x05query\x12\x16\n\x06schema\x18\x03\x20\x01(\tR\x06sch\
    ema\x12\x1a\n\x08database\x18\x04\x20\x01(\tR\x08database\x12\x1c\n\twar\
    ehouse\x18\x05\x20\x01(\tR\twarehouse\x1ao\n\x0cSparkOptions\x12\x14\n\
    \x05table\x18\x01\x20\x01(\tR\x05table\x12\x14\n\x05query\x18\x02\x20\
    \x01(\tR\x05query\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04path\x12\x1f\
    \n\x0bfile_format\x18\x04\x20\x01(\tR\nfileFormat\x1a;\n\x13CustomSource\
    Options\x12$\n\rconfiguration\x18\x01\x20\x01(\x0cR\rconfiguration\x1a\
    \x9d\x02\n\x12RequestDataOptions\x12l\n\x11deprecated_schema\x18\x02\x20\
    \x03(\x0b2?.feast.core.DataSource.RequestDataOptions.DeprecatedSchemaEnt\
    ryR\x10deprecatedSchema\x121\n\x06schema\x18\x03\x20\x03(\x0b2\x19.feast\
    .core.FeatureSpecV2R\x06schema\x1a`\n\x15DeprecatedSchemaEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x121\n\x05value\x18\x02\x20\x01(\x0e2\
    \x1b.feast.types.ValueType.EnumR\x05value:\x028\x01J\x04\x08\x01\x10\x02\
    \x1a\x13\n\x0bPushOptionsJ\x04\x08\x01\x10\x02\"\xf8\x01\n\nSourceType\
    \x12\x0b\n\x07INVALID\x10\0\x12\x0e\n\nBATCH_FILE\x10\x01\x12\x13\n\x0fB\
    ATCH_SNOWFLAKE\x10\x08\x12\x12\n\x0eBATCH_BIGQUERY\x10\x02\x12\x12\n\x0e\
    BATCH_REDSHIFT\x10\x05\x12\x10\n\x0cSTREAM_KAFKA\x10\x03\x12\x12\n\x0eST\
    REAM_KINESIS\x10\x04\x12\x11\n\rCUSTOM_SOURCE\x10\x06\x12\x12\n\x0eREQUE\
    ST_SOURCE\x10\x07\x12\x0f\n\x0bPUSH_SOURCE\x10\t\x12\x0f\n\x0bBATCH_TRIN\
    O\x10\n\x12\x0f\n\x0bBATCH_SPARK\x10\x0b\x12\x10\n\x0cBATCH_ATHENA\x10\
    \x0cB\t\n\x07optionsJ\x04\x08\x06\x10\x0bBT\n\x10feast.proto.coreB\x0fDa\
    taSourceProtoZ/github.com/feast-dev/feast/go/protos/feast/coreJ\xf9N\n\
    \x07\x12\x05\x11\0\x87\x02\x01\n\xc6\x04\n\x01\x0c\x12\x03\x11\0\x122\
    \xbb\x04\n\x20Copyright\x202020\x20The\x20Feast\x20Authors\n\n\x20Licens\
    ed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"\
    License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20i\
    n\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20\
    a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20https://w\
    ww.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20ap\
    plicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\
    \x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\n\x08\n\x01\x02\x12\x03\x12\0\x13\n\x08\n\x01\x08\x12\x03\x14\0F\n\
    \t\n\x02\x08\x0b\x12\x03\x14\0F\n\x08\n\x01\x08\x12\x03\x15\00\n\t\n\x02\
    \x08\x08\x12\x03\x15\00\n\x08\n\x01\x08\x12\x03\x16\0)\n\t\n\x02\x08\x01\
    \x12\x03\x16\0)\n\t\n\x02\x03\0\x12\x03\x18\0(\n\t\n\x02\x03\x01\x12\x03\
    \x19\0%\n\t\n\x02\x03\x02\x12\x03\x1a\0!\n\t\n\x02\x03\x03\x12\x03\x1b\0\
    \"\n`\n\x02\x04\0\x12\x05\x1f\0\x87\x02\x01\x1aS\x20Defines\x20a\x20Data\
    \x20Source\x20that\x20can\x20be\x20used\x20source\x20Feature\x20data\n\
    \x20Next\x20available\x20id:\x2028\n\n\n\n\x03\x04\0\x01\x12\x03\x1f\x08\
    \x12\n\xa9\x01\n\x03\x04\0\t\x12\x03\"\x02\x13\x1a\x9c\x01\x20Field\x20i\
    ndexes\x20should\x20*not*\x20be\x20reused.\x20Not\x20sure\x20if\x20field\
    s\x206-10\x20were\x20used\x20previously\x20or\x20not,\n\x20but\x20they\
    \x20are\x20going\x20to\x20be\x20reserved\x20for\x20backwards\x20compatib\
    ility.\n\n\x0b\n\x04\x04\0\t\0\x12\x03\"\x0b\x12\n\x0c\n\x05\x04\0\t\0\
    \x01\x12\x03\"\x0b\x0c\n\x0c\n\x05\x04\0\t\0\x02\x12\x03\"\x10\x12\n;\n\
    \x04\x04\0\x04\0\x12\x04&\x024\x03\x1a-\x20Type\x20of\x20Data\x20Source.\
    \n\x20Next\x20available\x20id:\x2012\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\
    \x03&\x07\x11\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03'\x04\x10\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x01\x12\x03'\x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x03'\x0e\x0f\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03(\x04\x13\n\
    \x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03(\x04\x0e\n\x0e\n\x07\x04\0\
    \x04\0\x02\x01\x02\x12\x03(\x11\x12\n\r\n\x06\x04\0\x04\0\x02\x02\x12\
    \x03)\x04\x18\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03)\x04\x13\n\x0e\
    \n\x07\x04\0\x04\0\x02\x02\x02\x12\x03)\x16\x17\n\r\n\x06\x04\0\x04\0\
    \x02\x03\x12\x03*\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\x03*\
    \x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03*\x15\x16\n\r\n\x06\
    \x04\0\x04\0\x02\x04\x12\x03+\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x04\
    \x01\x12\x03+\x04\x12\n\x0e\n\x07\x04\0\x04\0\x02\x04\x02\x12\x03+\x15\
    \x16\n\r\n\x06\x04\0\x04\0\x02\x05\x12\x03,\x04\x15\n\x0e\n\x07\x04\0\
    \x04\0\x02\x05\x01\x12\x03,\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x05\x02\
    \x12\x03,\x13\x14\n\r\n\x06\x04\0\x04\0\x02\x06\x12\x03-\x04\x17\n\x0e\n\
    \x07\x04\0\x04\0\x02\x06\x01\x12\x03-\x04\x12\n\x0e\n\x07\x04\0\x04\0\
    \x02\x06\x02\x12\x03-\x15\x16\n\r\n\x06\x04\0\x04\0\x02\x07\x12\x03.\x04\
    \x16\n\x0e\n\x07\x04\0\x04\0\x02\x07\x01\x12\x03.\x04\x11\n\x0e\n\x07\
    \x04\0\x04\0\x02\x07\x02\x12\x03.\x14\x15\n\r\n\x06\x04\0\x04\0\x02\x08\
    \x12\x03/\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x08\x01\x12\x03/\x04\x12\n\
    \x0e\n\x07\x04\0\x04\0\x02\x08\x02\x12\x03/\x15\x16\n\r\n\x06\x04\0\x04\
    \0\x02\t\x12\x030\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\t\x01\x12\x030\x04\
    \x0f\n\x0e\n\x07\x04\0\x04\0\x02\t\x02\x12\x030\x12\x13\n\r\n\x06\x04\0\
    \x04\0\x02\n\x12\x031\x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\n\x01\x12\x031\
    \x04\x0f\n\x0e\n\x07\x04\0\x04\0\x02\n\x02\x12\x031\x12\x14\n\r\n\x06\
    \x04\0\x04\0\x02\x0b\x12\x032\x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\x0b\
    \x01\x12\x032\x04\x0f\n\x0e\n\x07\x04\0\x04\0\x02\x0b\x02\x12\x032\x12\
    \x14\n\r\n\x06\x04\0\x04\0\x02\x0c\x12\x033\x04\x16\n\x0e\n\x07\x04\0\
    \x04\0\x02\x0c\x01\x12\x033\x04\x10\n\x0e\n\x07\x04\0\x04\0\x02\x0c\x02\
    \x12\x033\x13\x15\n<\n\x04\x04\0\x02\0\x12\x037\x02\x13\x1a/\x20Unique\
    \x20name\x20of\x20data\x20source\x20within\x20the\x20project\n\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x037\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x037\x10\x12\nF\n\x04\x04\0\
    \x02\x01\x12\x03:\x02\x16\x1a9\x20Name\x20of\x20Feast\x20project\x20that\
    \x20this\x20data\x20source\x20belongs\x20to.\n\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03:\t\x10\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03:\x13\x15\n\x0b\n\x04\x04\0\x02\x02\x12\
    \x03<\x02\x1a\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03<\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03<\t\x14\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03<\
    \x17\x19\n\x0b\n\x04\x04\0\x02\x03\x12\x03>\x02\x20\n\x0c\n\x05\x04\0\
    \x02\x03\x06\x12\x03>\x02\x15\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03>\x16\
    \x1a\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03>\x1d\x1f\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03@\x02\x14\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03@\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03@\t\x0e\n\x0c\n\x05\x04\0\x02\x04\
    \x03\x12\x03@\x11\x13\n\x0b\n\x04\x04\0\x02\x05\x12\x03B\x02\x16\n\x0c\n\
    \x05\x04\0\x02\x05\x06\x12\x03B\x02\x0c\n\x0c\n\x05\x04\0\x02\x05\x01\
    \x12\x03B\r\x11\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03B\x14\x15\ne\n\x04\
    \x04\0\x02\x06\x12\x03F\x02(\x1aX\x20Defines\x20mapping\x20between\x20fi\
    elds\x20in\x20the\x20sourced\x20data\n\x20and\x20fields\x20in\x20parent\
    \x20FeatureTable.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03F\x02\x15\n\x0c\
    \n\x05\x04\0\x02\x06\x01\x12\x03F\x16#\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03F&'\n7\n\x04\x04\0\x02\x07\x12\x03I\x02\x1d\x1a*\x20Must\x20specify\
    \x20event\x20timestamp\x20column\x20name\n\n\x0c\n\x05\x04\0\x02\x07\x05\
    \x12\x03I\x02\x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03I\t\x18\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03I\x1b\x1c\nK\n\x04\x04\0\x02\x08\x12\x03M\
    \x02#\x1a>\x20(Optional)\x20Specify\x20partition\x20column\n\x20useful\
    \x20for\x20file\x20sources\n\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03M\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03M\t\x1e\n\x0c\n\x05\x04\0\x02\
    \x08\x03\x12\x03M!\"\n:\n\x04\x04\0\x02\t\x12\x03P\x02&\x1a-\x20Must\x20\
    specify\x20creation\x20timestamp\x20column\x20name\n\n\x0c\n\x05\x04\0\
    \x02\t\x05\x12\x03P\x02\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03P\t!\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x03P$%\n\xbc\x02\n\x04\x04\0\x02\n\x12\
    \x03V\x02%\x1a\xae\x02\x20This\x20is\x20an\x20internal\x20field\x20that\
    \x20is\x20represents\x20the\x20python\x20class\x20for\x20the\x20data\x20\
    source\x20object\x20a\x20proto\x20object\x20represents.\n\x20This\x20sho\
    uld\x20be\x20set\x20by\x20feast,\x20and\x20not\x20by\x20users.\n\x20The\
    \x20field\x20is\x20used\x20primarily\x20by\x20custom\x20data\x20sources\
    \x20and\x20is\x20mandatory\x20for\x20them\x20to\x20set.\x20Feast\x20may\
    \x20set\x20it\x20for\n\x20first\x20party\x20sources\x20as\x20well.\n\n\
    \x0c\n\x05\x04\0\x02\n\x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\0\x02\n\x01\
    \x12\x03V\t\x1f\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03V\"$\ng\n\x04\x04\0\
    \x02\x0b\x12\x03Y\x02\x1f\x1aZ\x20Optional\x20batch\x20source\x20for\x20\
    streaming\x20sources\x20for\x20historical\x20features\x20and\x20material\
    ization.\n\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03Y\x02\x0c\n\x0c\n\x05\
    \x04\0\x02\x0b\x01\x12\x03Y\r\x19\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03Y\
    \x1c\x1e\nP\n\x04\x04\0\x03\x02\x12\x04]\x02h\x03\x1aB\x20Defines\x20opt\
    ions\x20for\x20DataSource\x20that\x20sources\x20features\x20from\x20a\
    \x20file\n\n\x0c\n\x05\x04\0\x03\x02\x01\x12\x03]\n\x15\n\r\n\x06\x04\0\
    \x03\x02\x02\0\x12\x03^\x04\x1f\n\x0e\n\x07\x04\0\x03\x02\x02\0\x06\x12\
    \x03^\x04\x0e\n\x0e\n\x07\x04\0\x03\x02\x02\0\x01\x12\x03^\x0f\x1a\n\x0e\
    \n\x07\x04\0\x03\x02\x02\0\x03\x12\x03^\x1d\x1e\n\xbf\x01\n\x06\x04\0\
    \x03\x02\x02\x01\x12\x03d\x04\x14\x1a\xaf\x01\x20Target\x20URL\x20of\x20\
    file\x20to\x20retrieve\x20and\x20source\x20features\x20from.\n\x20s3://p\
    ath/to/file\x20for\x20AWS\x20S3\x20storage\n\x20gs://path/to/file\x20for\
    \x20GCP\x20GCS\x20storage\n\x20file:///path/to/file\x20for\x20local\x20s\
    torage\n\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x05\x12\x03d\x04\n\n\x0e\n\
    \x07\x04\0\x03\x02\x02\x01\x01\x12\x03d\x0b\x0e\n\x0e\n\x07\x04\0\x03\
    \x02\x02\x01\x03\x12\x03d\x12\x13\nI\n\x06\x04\0\x03\x02\x02\x02\x12\x03\
    g\x04%\x1a:\x20override\x20AWS\x20S3\x20storage\x20endpoint\x20with\x20c\
    ustom\x20S3\x20endpoint\n\n\x0e\n\x07\x04\0\x03\x02\x02\x02\x05\x12\x03g\
    \x04\n\n\x0e\n\x07\x04\0\x03\x02\x02\x02\x01\x12\x03g\x0b\x1f\n\x0e\n\
    \x07\x04\0\x03\x02\x02\x02\x03\x12\x03g#$\nZ\n\x04\x04\0\x03\x03\x12\x04\
    k\x02r\x03\x1aL\x20Defines\x20options\x20for\x20DataSource\x20that\x20so\
    urces\x20features\x20from\x20a\x20BigQuery\x20Query\n\n\x0c\n\x05\x04\0\
    \x03\x03\x01\x12\x03k\n\x19\nL\n\x06\x04\0\x03\x03\x02\0\x12\x03m\x04\
    \x15\x1a=\x20Full\x20table\x20reference\x20in\x20the\x20form\x20of\x20[p\
    roject:dataset.table]\n\n\x0e\n\x07\x04\0\x03\x03\x02\0\x05\x12\x03m\x04\
    \n\n\x0e\n\x07\x04\0\x03\x03\x02\0\x01\x12\x03m\x0b\x10\n\x0e\n\x07\x04\
    \0\x03\x03\x02\0\x03\x12\x03m\x13\x14\n\x90\x01\n\x06\x04\0\x03\x03\x02\
    \x01\x12\x03q\x04\x15\x1a\x80\x01\x20SQL\x20query\x20that\x20returns\x20\
    a\x20table\x20containing\x20feature\x20data.\x20Must\x20contain\x20an\
    \x20event_timestamp\x20column,\x20and\x20respective\n\x20entity\x20colum\
    ns\n\n\x0e\n\x07\x04\0\x03\x03\x02\x01\x05\x12\x03q\x04\n\n\x0e\n\x07\
    \x04\0\x03\x03\x02\x01\x01\x12\x03q\x0b\x10\n\x0e\n\x07\x04\0\x03\x03\
    \x02\x01\x03\x12\x03q\x13\x14\nW\n\x04\x04\0\x03\x04\x12\x04u\x02|\x03\
    \x1aI\x20Defines\x20options\x20for\x20DataSource\x20that\x20sources\x20f\
    eatures\x20from\x20a\x20Trino\x20Query\n\n\x0c\n\x05\x04\0\x03\x04\x01\
    \x12\x03u\n\x16\nL\n\x06\x04\0\x03\x04\x02\0\x12\x03w\x04\x15\x1a=\x20Fu\
    ll\x20table\x20reference\x20in\x20the\x20form\x20of\x20[project:dataset.\
    table]\n\n\x0e\n\x07\x04\0\x03\x04\x02\0\x05\x12\x03w\x04\n\n\x0e\n\x07\
    \x04\0\x03\x04\x02\0\x01\x12\x03w\x0b\x10\n\x0e\n\x07\x04\0\x03\x04\x02\
    \0\x03\x12\x03w\x13\x14\n\x90\x01\n\x06\x04\0\x03\x04\x02\x01\x12\x03{\
    \x04\x15\x1a\x80\x01\x20SQL\x20query\x20that\x20returns\x20a\x20table\
    \x20containing\x20feature\x20data.\x20Must\x20contain\x20an\x20event_tim\
    estamp\x20column,\x20and\x20respective\n\x20entity\x20columns\n\n\x0e\n\
    \x07\x04\0\x03\x04\x02\x01\x05\x12\x03{\x04\n\n\x0e\n\x07\x04\0\x03\x04\
    \x02\x01\x01\x12\x03{\x0b\x10\n\x0e\n\x07\x04\0\x03\x04\x02\x01\x03\x12\
    \x03{\x13\x14\n\xd3\x01\n\x04\x04\0\x03\x05\x12\x06\x81\x01\x02\x8d\x01\
    \x03\x1a\xc2\x01\x20Defines\x20options\x20for\x20DataSource\x20that\x20s\
    ources\x20features\x20from\x20Kafka\x20messages.\n\x20Each\x20message\
    \x20should\x20be\x20a\x20Protobuf\x20that\x20can\x20be\x20decoded\x20wit\
    h\x20the\x20generated\n\x20Java\x20Protobuf\x20class\x20at\x20the\x20giv\
    en\x20class\x20path\n\n\r\n\x05\x04\0\x03\x05\x01\x12\x04\x81\x01\n\x16\
    \n\x80\x01\n\x06\x04\0\x03\x05\x02\0\x12\x04\x83\x01\x04'\x1ap\x20Comma\
    \x20separated\x20list\x20of\x20Kafka\x20bootstrap\x20servers.\x20Used\
    \x20for\x20feature\x20tables\x20without\x20a\x20defined\x20source\x20hos\
    t[:port]]\n\n\x0f\n\x07\x04\0\x03\x05\x02\0\x05\x12\x04\x83\x01\x04\n\n\
    \x0f\n\x07\x04\0\x03\x05\x02\0\x01\x12\x04\x83\x01\x0b\"\n\x0f\n\x07\x04\
    \0\x03\x05\x02\0\x03\x12\x04\x83\x01%&\n;\n\x06\x04\0\x03\x05\x02\x01\
    \x12\x04\x86\x01\x04\x15\x1a+\x20Kafka\x20topic\x20to\x20collect\x20feat\
    ure\x20data\x20from.\n\n\x0f\n\x07\x04\0\x03\x05\x02\x01\x05\x12\x04\x86\
    \x01\x04\n\n\x0f\n\x07\x04\0\x03\x05\x02\x01\x01\x12\x04\x86\x01\x0b\x10\
    \n\x0f\n\x07\x04\0\x03\x05\x02\x01\x03\x12\x04\x86\x01\x13\x14\n`\n\x06\
    \x04\0\x03\x05\x02\x02\x12\x04\x89\x01\x04$\x1aP\x20Defines\x20the\x20st\
    ream\x20data\x20format\x20encoding\x20feature/entity\x20data\x20in\x20Ka\
    fka\x20messages.\n\n\x0f\n\x07\x04\0\x03\x05\x02\x02\x06\x12\x04\x89\x01\
    \x04\x10\n\x0f\n\x07\x04\0\x03\x05\x02\x02\x01\x12\x04\x89\x01\x11\x1f\n\
    \x0f\n\x07\x04\0\x03\x05\x02\x02\x03\x12\x04\x89\x01\"#\n;\n\x06\x04\0\
    \x03\x05\x02\x03\x12\x04\x8c\x01\x04;\x1a+\x20Watermark\x20delay\x20thre\
    shold\x20for\x20stream\x20data\n\n\x0f\n\x07\x04\0\x03\x05\x02\x03\x06\
    \x12\x04\x8c\x01\x04\x1c\n\x0f\n\x07\x04\0\x03\x05\x02\x03\x01\x12\x04\
    \x8c\x01\x1d6\n\x0f\n\x07\x04\0\x03\x05\x02\x03\x03\x12\x04\x8c\x019:\n\
    \xd3\x01\n\x04\x04\0\x03\x06\x12\x06\x92\x01\x02\x9c\x01\x03\x1a\xc2\x01\
    \x20Defines\x20options\x20for\x20DataSource\x20that\x20sources\x20featur\
    es\x20from\x20Kinesis\x20records.\n\x20Each\x20record\x20should\x20be\
    \x20a\x20Protobuf\x20that\x20can\x20be\x20decoded\x20with\x20the\x20gene\
    rated\n\x20Java\x20Protobuf\x20class\x20at\x20the\x20given\x20class\x20p\
    ath\n\n\r\n\x05\x04\0\x03\x06\x01\x12\x04\x92\x01\n\x18\n2\n\x06\x04\0\
    \x03\x06\x02\0\x12\x04\x94\x01\x04\x16\x1a\"\x20AWS\x20region\x20of\x20t\
    he\x20Kinesis\x20stream\n\n\x0f\n\x07\x04\0\x03\x06\x02\0\x05\x12\x04\
    \x94\x01\x04\n\n\x0f\n\x07\x04\0\x03\x06\x02\0\x01\x12\x04\x94\x01\x0b\
    \x11\n\x0f\n\x07\x04\0\x03\x06\x02\0\x03\x12\x04\x94\x01\x14\x15\nI\n\
    \x06\x04\0\x03\x06\x02\x01\x12\x04\x97\x01\x04\x1b\x1a9\x20Name\x20of\
    \x20the\x20Kinesis\x20stream\x20to\x20obtain\x20feature\x20data\x20from.\
    \n\n\x0f\n\x07\x04\0\x03\x06\x02\x01\x05\x12\x04\x97\x01\x04\n\n\x0f\n\
    \x07\x04\0\x03\x06\x02\x01\x01\x12\x04\x97\x01\x0b\x16\n\x0f\n\x07\x04\0\
    \x03\x06\x02\x01\x03\x12\x04\x97\x01\x19\x1a\n\x9d\x01\n\x06\x04\0\x03\
    \x06\x02\x02\x12\x04\x9b\x01\x04#\x1a\x8c\x01\x20Defines\x20the\x20data\
    \x20format\x20encoding\x20the\x20feature/entity\x20data\x20in\x20Kinesis\
    \x20records.\n\x20Kinesis\x20Data\x20Sources\x20support\x20Avro\x20and\
    \x20Proto\x20as\x20data\x20formats.\n\n\x0f\n\x07\x04\0\x03\x06\x02\x02\
    \x06\x12\x04\x9b\x01\x04\x10\n\x0f\n\x07\x04\0\x03\x06\x02\x02\x01\x12\
    \x04\x9b\x01\x11\x1e\n\x0f\n\x07\x04\0\x03\x06\x02\x02\x03\x12\x04\x9b\
    \x01!\"\n\\\n\x04\x04\0\x03\x07\x12\x06\x9f\x01\x02\xac\x01\x03\x1aL\x20\
    Defines\x20options\x20for\x20DataSource\x20that\x20sources\x20features\
    \x20from\x20a\x20Redshift\x20Query\n\n\r\n\x05\x04\0\x03\x07\x01\x12\x04\
    \x9f\x01\n\x19\n%\n\x06\x04\0\x03\x07\x02\0\x12\x04\xa1\x01\x04\x15\x1a\
    \x15\x20Redshift\x20table\x20name\n\n\x0f\n\x07\x04\0\x03\x07\x02\0\x05\
    \x12\x04\xa1\x01\x04\n\n\x0f\n\x07\x04\0\x03\x07\x02\0\x01\x12\x04\xa1\
    \x01\x0b\x10\n\x0f\n\x07\x04\0\x03\x07\x02\0\x03\x12\x04\xa1\x01\x13\x14\
    \n\x91\x01\n\x06\x04\0\x03\x07\x02\x01\x12\x04\xa5\x01\x04\x15\x1a\x80\
    \x01\x20SQL\x20query\x20that\x20returns\x20a\x20table\x20containing\x20f\
    eature\x20data.\x20Must\x20contain\x20an\x20event_timestamp\x20column,\
    \x20and\x20respective\n\x20entity\x20columns\n\n\x0f\n\x07\x04\0\x03\x07\
    \x02\x01\x05\x12\x04\xa5\x01\x04\n\n\x0f\n\x07\x04\0\x03\x07\x02\x01\x01\
    \x12\x04\xa5\x01\x0b\x10\n\x0f\n\x07\x04\0\x03\x07\x02\x01\x03\x12\x04\
    \xa5\x01\x13\x14\n&\n\x06\x04\0\x03\x07\x02\x02\x12\x04\xa8\x01\x04\x16\
    \x1a\x16\x20Redshift\x20schema\x20name\n\n\x0f\n\x07\x04\0\x03\x07\x02\
    \x02\x05\x12\x04\xa8\x01\x04\n\n\x0f\n\x07\x04\0\x03\x07\x02\x02\x01\x12\
    \x04\xa8\x01\x0b\x11\n\x0f\n\x07\x04\0\x03\x07\x02\x02\x03\x12\x04\xa8\
    \x01\x14\x15\n(\n\x06\x04\0\x03\x07\x02\x03\x12\x04\xab\x01\x04\x18\x1a\
    \x18\x20Redshift\x20database\x20name\n\n\x0f\n\x07\x04\0\x03\x07\x02\x03\
    \x05\x12\x04\xab\x01\x04\n\n\x0f\n\x07\x04\0\x03\x07\x02\x03\x01\x12\x04\
    \xab\x01\x0b\x13\n\x0f\n\x07\x04\0\x03\x07\x02\x03\x03\x12\x04\xab\x01\
    \x16\x17\nZ\n\x04\x04\0\x03\x08\x12\x06\xaf\x01\x02\xbc\x01\x03\x1aJ\x20\
    Defines\x20options\x20for\x20DataSource\x20that\x20sources\x20features\
    \x20from\x20a\x20Athena\x20Query\n\n\r\n\x05\x04\0\x03\x08\x01\x12\x04\
    \xaf\x01\n\x17\n#\n\x06\x04\0\x03\x08\x02\0\x12\x04\xb1\x01\x04\x15\x1a\
    \x13\x20Athena\x20table\x20name\n\n\x0f\n\x07\x04\0\x03\x08\x02\0\x05\
    \x12\x04\xb1\x01\x04\n\n\x0f\n\x07\x04\0\x03\x08\x02\0\x01\x12\x04\xb1\
    \x01\x0b\x10\n\x0f\n\x07\x04\0\x03\x08\x02\0\x03\x12\x04\xb1\x01\x13\x14\
    \n\x91\x01\n\x06\x04\0\x03\x08\x02\x01\x12\x04\xb5\x01\x04\x15\x1a\x80\
    \x01\x20SQL\x20query\x20that\x20returns\x20a\x20table\x20containing\x20f\
    eature\x20data.\x20Must\x20contain\x20an\x20event_timestamp\x20column,\
    \x20and\x20respective\n\x20entity\x20columns\n\n\x0f\n\x07\x04\0\x03\x08\
    \x02\x01\x05\x12\x04\xb5\x01\x04\n\n\x0f\n\x07\x04\0\x03\x08\x02\x01\x01\
    \x12\x04\xb5\x01\x0b\x10\n\x0f\n\x07\x04\0\x03\x08\x02\x01\x03\x12\x04\
    \xb5\x01\x13\x14\n&\n\x06\x04\0\x03\x08\x02\x02\x12\x04\xb8\x01\x04\x18\
    \x1a\x16\x20Athena\x20database\x20name\n\n\x0f\n\x07\x04\0\x03\x08\x02\
    \x02\x05\x12\x04\xb8\x01\x04\n\n\x0f\n\x07\x04\0\x03\x08\x02\x02\x01\x12\
    \x04\xb8\x01\x0b\x13\n\x0f\n\x07\x04\0\x03\x08\x02\x02\x03\x12\x04\xb8\
    \x01\x16\x17\n$\n\x06\x04\0\x03\x08\x02\x03\x12\x04\xbb\x01\x04\x1b\x1a\
    \x14\x20Athena\x20schema\x20name\n\n\x0f\n\x07\x04\0\x03\x08\x02\x03\x05\
    \x12\x04\xbb\x01\x04\n\n\x0f\n\x07\x04\0\x03\x08\x02\x03\x01\x12\x04\xbb\
    \x01\x0b\x16\n\x0f\n\x07\x04\0\x03\x08\x02\x03\x03\x12\x04\xbb\x01\x19\
    \x1a\n]\n\x04\x04\0\x03\t\x12\x06\xbf\x01\x02\xcf\x01\x03\x1aM\x20Define\
    s\x20options\x20for\x20DataSource\x20that\x20sources\x20features\x20from\
    \x20a\x20Snowflake\x20Query\n\n\r\n\x05\x04\0\x03\t\x01\x12\x04\xbf\x01\
    \n\x1a\n&\n\x06\x04\0\x03\t\x02\0\x12\x04\xc1\x01\x04\x15\x1a\x16\x20Sno\
    wflake\x20table\x20name\n\n\x0f\n\x07\x04\0\x03\t\x02\0\x05\x12\x04\xc1\
    \x01\x04\n\n\x0f\n\x07\x04\0\x03\t\x02\0\x01\x12\x04\xc1\x01\x0b\x10\n\
    \x0f\n\x07\x04\0\x03\t\x02\0\x03\x12\x04\xc1\x01\x13\x14\n\x91\x01\n\x06\
    \x04\0\x03\t\x02\x01\x12\x04\xc5\x01\x04\x15\x1a\x80\x01\x20SQL\x20query\
    \x20that\x20returns\x20a\x20table\x20containing\x20feature\x20data.\x20M\
    ust\x20contain\x20an\x20event_timestamp\x20column,\x20and\x20respective\
    \n\x20entity\x20columns\n\n\x0f\n\x07\x04\0\x03\t\x02\x01\x05\x12\x04\
    \xc5\x01\x04\n\n\x0f\n\x07\x04\0\x03\t\x02\x01\x01\x12\x04\xc5\x01\x0b\
    \x10\n\x0f\n\x07\x04\0\x03\t\x02\x01\x03\x12\x04\xc5\x01\x13\x14\n'\n\
    \x06\x04\0\x03\t\x02\x02\x12\x04\xc8\x01\x04\x16\x1a\x17\x20Snowflake\
    \x20schema\x20name\n\n\x0f\n\x07\x04\0\x03\t\x02\x02\x05\x12\x04\xc8\x01\
    \x04\n\n\x0f\n\x07\x04\0\x03\t\x02\x02\x01\x12\x04\xc8\x01\x0b\x11\n\x0f\
    \n\x07\x04\0\x03\t\x02\x02\x03\x12\x04\xc8\x01\x14\x15\n'\n\x06\x04\0\
    \x03\t\x02\x03\x12\x04\xcb\x01\x04\x18\x1a\x17\x20Snowflake\x20schema\
    \x20name\n\n\x0f\n\x07\x04\0\x03\t\x02\x03\x05\x12\x04\xcb\x01\x04\n\n\
    \x0f\n\x07\x04\0\x03\t\x02\x03\x01\x12\x04\xcb\x01\x0b\x13\n\x0f\n\x07\
    \x04\0\x03\t\x02\x03\x03\x12\x04\xcb\x01\x16\x17\n*\n\x06\x04\0\x03\t\
    \x02\x04\x12\x04\xce\x01\x04\x19\x1a\x1a\x20Snowflake\x20warehouse\x20na\
    me\n\n\x0f\n\x07\x04\0\x03\t\x02\x04\x05\x12\x04\xce\x01\x04\n\n\x0f\n\
    \x07\x04\0\x03\t\x02\x04\x01\x12\x04\xce\x01\x0b\x14\n\x0f\n\x07\x04\0\
    \x03\t\x02\x04\x03\x12\x04\xce\x01\x17\x18\n_\n\x04\x04\0\x03\n\x12\x06\
    \xd2\x01\x02\xde\x01\x03\x1aO\x20Defines\x20options\x20for\x20DataSource\
    \x20that\x20sources\x20features\x20from\x20a\x20spark\x20table/query\n\n\
    \r\n\x05\x04\0\x03\n\x01\x12\x04\xd2\x01\n\x16\n\x1c\n\x06\x04\0\x03\n\
    \x02\0\x12\x04\xd4\x01\x04\x15\x1a\x0c\x20Table\x20name\n\n\x0f\n\x07\
    \x04\0\x03\n\x02\0\x05\x12\x04\xd4\x01\x04\n\n\x0f\n\x07\x04\0\x03\n\x02\
    \0\x01\x12\x04\xd4\x01\x0b\x10\n\x0f\n\x07\x04\0\x03\n\x02\0\x03\x12\x04\
    \xd4\x01\x13\x14\n[\n\x06\x04\0\x03\n\x02\x01\x12\x04\xd7\x01\x04\x15\
    \x1aK\x20Spark\x20SQl\x20query\x20that\x20returns\x20the\x20table,\x20th\
    is\x20is\x20an\x20alternative\x20to\x20`table`\n\n\x0f\n\x07\x04\0\x03\n\
    \x02\x01\x05\x12\x04\xd7\x01\x04\n\n\x0f\n\x07\x04\0\x03\n\x02\x01\x01\
    \x12\x04\xd7\x01\x0b\x10\n\x0f\n\x07\x04\0\x03\n\x02\x01\x03\x12\x04\xd7\
    \x01\x13\x14\n]\n\x06\x04\0\x03\n\x02\x02\x12\x04\xda\x01\x04\x14\x1aM\
    \x20Path\x20from\x20which\x20spark\x20can\x20read\x20the\x20table,\x20th\
    is\x20is\x20an\x20alternative\x20to\x20`table`\n\n\x0f\n\x07\x04\0\x03\n\
    \x02\x02\x05\x12\x04\xda\x01\x04\n\n\x0f\n\x07\x04\0\x03\n\x02\x02\x01\
    \x12\x04\xda\x01\x0b\x0f\n\x0f\n\x07\x04\0\x03\n\x02\x02\x03\x12\x04\xda\
    \x01\x12\x13\nE\n\x06\x04\0\x03\n\x02\x03\x12\x04\xdd\x01\x04\x1b\x1a5\
    \x20Format\x20of\x20files\x20at\x20`path`\x20(e.g.\x20parquet,\x20avro,\
    \x20etc)\n\n\x0f\n\x07\x04\0\x03\n\x02\x03\x05\x12\x04\xdd\x01\x04\n\n\
    \x0f\n\x07\x04\0\x03\n\x02\x03\x01\x12\x04\xdd\x01\x0b\x16\n\x0f\n\x07\
    \x04\0\x03\n\x02\x03\x03\x12\x04\xdd\x01\x19\x1a\nL\n\x04\x04\0\x03\x0b\
    \x12\x06\xe1\x01\x02\xe5\x01\x03\x1a<\x20Defines\x20configuration\x20for\
    \x20custom\x20third-party\x20data\x20sources.\n\n\r\n\x05\x04\0\x03\x0b\
    \x01\x12\x04\xe1\x01\n\x1d\n\xb8\x01\n\x06\x04\0\x03\x0b\x02\0\x12\x04\
    \xe4\x01\x04\x1c\x1a\xa7\x01\x20Serialized\x20configuration\x20informati\
    on\x20for\x20the\x20data\x20source.\x20The\x20implementer\x20of\x20the\
    \x20custom\x20data\x20source\x20is\n\x20responsible\x20for\x20serializin\
    g\x20and\x20deserializing\x20data\x20from\x20bytes\n\n\x0f\n\x07\x04\0\
    \x03\x0b\x02\0\x05\x12\x04\xe4\x01\x04\t\n\x0f\n\x07\x04\0\x03\x0b\x02\0\
    \x01\x12\x04\xe4\x01\n\x17\n\x0f\n\x07\x04\0\x03\x0b\x02\0\x03\x12\x04\
    \xe4\x01\x1a\x1b\nX\n\x04\x04\0\x03\x0c\x12\x06\xe8\x01\x02\xef\x01\x03\
    \x1aH\x20Defines\x20options\x20for\x20DataSource\x20that\x20sources\x20f\
    eatures\x20from\x20request\x20data\n\n\r\n\x05\x04\0\x03\x0c\x01\x12\x04\
    \xe8\x01\n\x1c\n\r\n\x05\x04\0\x03\x0c\t\x12\x04\xe9\x01\x04\x0f\n\x0e\n\
    \x06\x04\0\x03\x0c\t\0\x12\x04\xe9\x01\r\x0e\n\x0f\n\x07\x04\0\x03\x0c\t\
    \0\x01\x12\x04\xe9\x01\r\x0e\n\x0f\n\x07\x04\0\x03\x0c\t\0\x02\x12\x04\
    \xe9\x01\r\x0e\n1\n\x06\x04\0\x03\x0c\x02\0\x12\x04\xeb\x01\x04B\x1a!\
    \x20Mapping\x20of\x20feature\x20name\x20to\x20type\n\n\x0f\n\x07\x04\0\
    \x03\x0c\x02\0\x06\x12\x04\xeb\x01\x04+\n\x0f\n\x07\x04\0\x03\x0c\x02\0\
    \x01\x12\x04\xeb\x01,=\n\x0f\n\x07\x04\0\x03\x0c\x02\0\x03\x12\x04\xeb\
    \x01@A\n\x0e\n\x06\x04\0\x03\x0c\x02\x01\x12\x04\xed\x01\x04&\n\x0f\n\
    \x07\x04\0\x03\x0c\x02\x01\x04\x12\x04\xed\x01\x04\x0c\n\x0f\n\x07\x04\0\
    \x03\x0c\x02\x01\x06\x12\x04\xed\x01\r\x1a\n\x0f\n\x07\x04\0\x03\x0c\x02\
    \x01\x01\x12\x04\xed\x01\x1b!\n\x0f\n\x07\x04\0\x03\x0c\x02\x01\x03\x12\
    \x04\xed\x01$%\n\xae\x01\n\x04\x04\0\x03\r\x12\x06\xf3\x01\x02\xf5\x01\
    \x03\x1a\x9d\x01\x20Defines\x20options\x20for\x20DataSource\x20that\x20s\
    upports\x20pushing\x20data\x20to\x20it.\x20This\x20allows\x20data\x20to\
    \x20be\x20pushed\x20to\n\x20the\x20online\x20store\x20on-demand,\x20such\
    \x20as\x20by\x20stream\x20consumers.\n\n\r\n\x05\x04\0\x03\r\x01\x12\x04\
    \xf3\x01\n\x15\n\r\n\x05\x04\0\x03\r\t\x12\x04\xf4\x01\x04\x0f\n\x0e\n\
    \x06\x04\0\x03\r\t\0\x12\x04\xf4\x01\r\x0e\n\x0f\n\x07\x04\0\x03\r\t\0\
    \x01\x12\x04\xf4\x01\r\x0e\n\x0f\n\x07\x04\0\x03\r\t\0\x02\x12\x04\xf4\
    \x01\r\x0e\n%\n\x04\x04\0\x08\0\x12\x06\xf9\x01\x02\x86\x02\x03\x1a\x15\
    \x20DataSource\x20options.\n\n\r\n\x05\x04\0\x08\0\x01\x12\x04\xf9\x01\
    \x08\x0f\n\x0c\n\x04\x04\0\x02\x0c\x12\x04\xfa\x01\x04\"\n\r\n\x05\x04\0\
    \x02\x0c\x06\x12\x04\xfa\x01\x04\x0f\n\r\n\x05\x04\0\x02\x0c\x01\x12\x04\
    \xfa\x01\x10\x1c\n\r\n\x05\x04\0\x02\x0c\x03\x12\x04\xfa\x01\x1f!\n\x0c\
    \n\x04\x04\0\x02\r\x12\x04\xfb\x01\x04*\n\r\n\x05\x04\0\x02\r\x06\x12\
    \x04\xfb\x01\x04\x13\n\r\n\x05\x04\0\x02\r\x01\x12\x04\xfb\x01\x14$\n\r\
    \n\x05\x04\0\x02\r\x03\x12\x04\xfb\x01')\n\x0c\n\x04\x04\0\x02\x0e\x12\
    \x04\xfc\x01\x04$\n\r\n\x05\x04\0\x02\x0e\x06\x12\x04\xfc\x01\x04\x10\n\
    \r\n\x05\x04\0\x02\x0e\x01\x12\x04\xfc\x01\x11\x1e\n\r\n\x05\x04\0\x02\
    \x0e\x03\x12\x04\xfc\x01!#\n\x0c\n\x04\x04\0\x02\x0f\x12\x04\xfd\x01\x04\
    (\n\r\n\x05\x04\0\x02\x0f\x06\x12\x04\xfd\x01\x04\x12\n\r\n\x05\x04\0\
    \x02\x0f\x01\x12\x04\xfd\x01\x13\"\n\r\n\x05\x04\0\x02\x0f\x03\x12\x04\
    \xfd\x01%'\n\x0c\n\x04\x04\0\x02\x10\x12\x04\xfe\x01\x04*\n\r\n\x05\x04\
    \0\x02\x10\x06\x12\x04\xfe\x01\x04\x13\n\r\n\x05\x04\0\x02\x10\x01\x12\
    \x04\xfe\x01\x14$\n\r\n\x05\x04\0\x02\x10\x03\x12\x04\xfe\x01')\n\x0c\n\
    \x04\x04\0\x02\x11\x12\x04\xff\x01\x041\n\r\n\x05\x04\0\x02\x11\x06\x12\
    \x04\xff\x01\x04\x16\n\r\n\x05\x04\0\x02\x11\x01\x12\x04\xff\x01\x17+\n\
    \r\n\x05\x04\0\x02\x11\x03\x12\x04\xff\x01.0\n\x0c\n\x04\x04\0\x02\x12\
    \x12\x04\x80\x02\x04,\n\r\n\x05\x04\0\x02\x12\x06\x12\x04\x80\x02\x04\
    \x17\n\r\n\x05\x04\0\x02\x12\x01\x12\x04\x80\x02\x18&\n\r\n\x05\x04\0\
    \x02\x12\x03\x12\x04\x80\x02)+\n\x0c\n\x04\x04\0\x02\x13\x12\x04\x81\x02\
    \x04,\n\r\n\x05\x04\0\x02\x13\x06\x12\x04\x81\x02\x04\x14\n\r\n\x05\x04\
    \0\x02\x13\x01\x12\x04\x81\x02\x15&\n\r\n\x05\x04\0\x02\x13\x03\x12\x04\
    \x81\x02)+\n\x0c\n\x04\x04\0\x02\x14\x12\x04\x82\x02\x04\"\n\r\n\x05\x04\
    \0\x02\x14\x06\x12\x04\x82\x02\x04\x0f\n\r\n\x05\x04\0\x02\x14\x01\x12\
    \x04\x82\x02\x10\x1c\n\r\n\x05\x04\0\x02\x14\x03\x12\x04\x82\x02\x1f!\n\
    \x0c\n\x04\x04\0\x02\x15\x12\x04\x83\x02\x04$\n\r\n\x05\x04\0\x02\x15\
    \x06\x12\x04\x83\x02\x04\x10\n\r\n\x05\x04\0\x02\x15\x01\x12\x04\x83\x02\
    \x11\x1e\n\r\n\x05\x04\0\x02\x15\x03\x12\x04\x83\x02!#\n\x0c\n\x04\x04\0\
    \x02\x16\x12\x04\x84\x02\x04$\n\r\n\x05\x04\0\x02\x16\x06\x12\x04\x84\
    \x02\x04\x10\n\r\n\x05\x04\0\x02\x16\x01\x12\x04\x84\x02\x11\x1e\n\r\n\
    \x05\x04\0\x02\x16\x03\x12\x04\x84\x02!#\n\x0c\n\x04\x04\0\x02\x17\x12\
    \x04\x85\x02\x04&\n\r\n\x05\x04\0\x02\x17\x06\x12\x04\x85\x02\x04\x11\n\
    \r\n\x05\x04\0\x02\x17\x01\x12\x04\x85\x02\x12\x20\n\r\n\x05\x04\0\x02\
    \x17\x03\x12\x04\x85\x02#%b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(super::DataFormat::file_descriptor().clone());
            deps.push(super::Value::file_descriptor().clone());
            deps.push(super::Feature::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(13);
            messages.push(DataSource::generated_message_descriptor_data());
            messages.push(data_source::FileOptions::generated_message_descriptor_data());
            messages.push(data_source::BigQueryOptions::generated_message_descriptor_data());
            messages.push(data_source::TrinoOptions::generated_message_descriptor_data());
            messages.push(data_source::KafkaOptions::generated_message_descriptor_data());
            messages.push(data_source::KinesisOptions::generated_message_descriptor_data());
            messages.push(data_source::RedshiftOptions::generated_message_descriptor_data());
            messages.push(data_source::AthenaOptions::generated_message_descriptor_data());
            messages.push(data_source::SnowflakeOptions::generated_message_descriptor_data());
            messages.push(data_source::SparkOptions::generated_message_descriptor_data());
            messages.push(data_source::CustomSourceOptions::generated_message_descriptor_data());
            messages.push(data_source::RequestDataOptions::generated_message_descriptor_data());
            messages.push(data_source::PushOptions::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(data_source::SourceType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
